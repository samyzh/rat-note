<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>vue相关汇总 | 写作认知体系</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/rat-summ/img/favicon.ico">
    <link rel="manifest" href="/rat-summ/manifest.json">
    <script charset="utf-8" src="/rat-summ/js/readmore.js"></script>
    <meta name="description" content="title: vue相关汇总
date: 2021-03-27 11:02:25
permalink: /pages/57e70c/">
    <meta name="image" content="https://my.samyz.cn/_image/01.vue相关汇总/eca9d99af4a749f485360bdb460a16e0~tplv-k3u1fbpfcp-zoom-1.png">
    <meta name="twitter:title" content="vue相关汇总">
    <meta name="twitter:description" content="title: vue相关汇总
date: 2021-03-27 11:02:25
permalink: /pages/57e70c/">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="https://my.samyz.cn/_image/01.vue相关汇总/eca9d99af4a749f485360bdb460a16e0~tplv-k3u1fbpfcp-zoom-1.png">
    <meta name="twitter:url" content="https://my.samyz.cn/%E3%80%8A%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7%E3%80%8B/01.vue%E7%9B%B8%E5%85%B3/01.vue%E7%9B%B8%E5%85%B3%E6%B1%87%E6%80%BB.html">
    <meta property="og:type" content="article">
    <meta property="og:title" content="vue相关汇总">
    <meta property="og:description" content="title: vue相关汇总
date: 2021-03-27 11:02:25
permalink: /pages/57e70c/">
    <meta property="og:image" content="https://my.samyz.cn/_image/01.vue相关汇总/eca9d99af4a749f485360bdb460a16e0~tplv-k3u1fbpfcp-zoom-1.png">
    <meta property="og:url" content="https://my.samyz.cn/%E3%80%8A%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7%E3%80%8B/01.vue%E7%9B%B8%E5%85%B3/01.vue%E7%9B%B8%E5%85%B3%E6%B1%87%E6%80%BB.html">
    <meta property="og:site_name" content="samyzh">
    <meta property="article:published_time" content="2021-06-25T15:40:54.000Z">
    <meta itemprop="name" content="vue相关汇总">
    <meta itemprop="description" content="title: vue相关汇总
date: 2021-03-27 11:02:25
permalink: /pages/57e70c/">
    <meta itemprop="image" content="https://my.samyz.cn/_image/01.vue相关汇总/eca9d99af4a749f485360bdb460a16e0~tplv-k3u1fbpfcp-zoom-1.png">
    <meta name="keywords" content="vuepress,theme,doc">
    <meta name="theme-color" content="#11a8cd">
    <link rel="preload" href="/rat-summ/assets/css/0.styles.ea37c4a1.css" as="style"><link rel="preload" href="/rat-summ/assets/js/app.d4fe6087.js" as="script"><link rel="preload" href="/rat-summ/assets/js/2.d4f28c34.js" as="script"><link rel="preload" href="/rat-summ/assets/js/32.627a4eb6.js" as="script"><link rel="preload" href="/rat-summ/assets/js/96.e18c84a7.js" as="script"><link rel="prefetch" href="/rat-summ/assets/js/10.e0df923c.js"><link rel="prefetch" href="/rat-summ/assets/js/100.25be9ef0.js"><link rel="prefetch" href="/rat-summ/assets/js/101.c84290a3.js"><link rel="prefetch" href="/rat-summ/assets/js/102.d6b4302a.js"><link rel="prefetch" href="/rat-summ/assets/js/103.f33cc793.js"><link rel="prefetch" href="/rat-summ/assets/js/104.83f8c1df.js"><link rel="prefetch" href="/rat-summ/assets/js/105.2e81b140.js"><link rel="prefetch" href="/rat-summ/assets/js/106.f6622f2a.js"><link rel="prefetch" href="/rat-summ/assets/js/107.65c08c5c.js"><link rel="prefetch" href="/rat-summ/assets/js/108.12bdc92a.js"><link rel="prefetch" href="/rat-summ/assets/js/109.c31f0f64.js"><link rel="prefetch" href="/rat-summ/assets/js/11.761c5f87.js"><link rel="prefetch" href="/rat-summ/assets/js/110.66080278.js"><link rel="prefetch" href="/rat-summ/assets/js/111.c1032fe7.js"><link rel="prefetch" href="/rat-summ/assets/js/112.7ad7365d.js"><link rel="prefetch" href="/rat-summ/assets/js/113.5e71cf1b.js"><link rel="prefetch" href="/rat-summ/assets/js/114.0a3bd36a.js"><link rel="prefetch" href="/rat-summ/assets/js/115.53363169.js"><link rel="prefetch" href="/rat-summ/assets/js/116.96a79a63.js"><link rel="prefetch" href="/rat-summ/assets/js/117.42ebbdaa.js"><link rel="prefetch" href="/rat-summ/assets/js/118.7e52785e.js"><link rel="prefetch" href="/rat-summ/assets/js/119.231e32e9.js"><link rel="prefetch" href="/rat-summ/assets/js/12.9bb2c2e0.js"><link rel="prefetch" href="/rat-summ/assets/js/120.6026cc40.js"><link rel="prefetch" href="/rat-summ/assets/js/121.0a2eda80.js"><link rel="prefetch" href="/rat-summ/assets/js/122.6615a459.js"><link rel="prefetch" href="/rat-summ/assets/js/123.96b17f7b.js"><link rel="prefetch" href="/rat-summ/assets/js/124.a9cffdc3.js"><link rel="prefetch" href="/rat-summ/assets/js/125.3aedfc5f.js"><link rel="prefetch" href="/rat-summ/assets/js/126.e1dad155.js"><link rel="prefetch" href="/rat-summ/assets/js/127.24df170f.js"><link rel="prefetch" href="/rat-summ/assets/js/128.f8bf85e3.js"><link rel="prefetch" href="/rat-summ/assets/js/129.3ebe7248.js"><link rel="prefetch" href="/rat-summ/assets/js/13.acbd01a0.js"><link rel="prefetch" href="/rat-summ/assets/js/130.8a2b0a0e.js"><link rel="prefetch" href="/rat-summ/assets/js/131.bde5325c.js"><link rel="prefetch" href="/rat-summ/assets/js/132.2ddb7e3c.js"><link rel="prefetch" href="/rat-summ/assets/js/133.1ebc2bc1.js"><link rel="prefetch" href="/rat-summ/assets/js/134.c45d4cea.js"><link rel="prefetch" href="/rat-summ/assets/js/135.ac17b33e.js"><link rel="prefetch" href="/rat-summ/assets/js/136.d83882c9.js"><link rel="prefetch" href="/rat-summ/assets/js/137.fd7e6efe.js"><link rel="prefetch" href="/rat-summ/assets/js/138.22a3c306.js"><link rel="prefetch" href="/rat-summ/assets/js/139.dfdd6379.js"><link rel="prefetch" href="/rat-summ/assets/js/14.f5de695b.js"><link rel="prefetch" href="/rat-summ/assets/js/140.700d9f69.js"><link rel="prefetch" href="/rat-summ/assets/js/141.e3b0221e.js"><link rel="prefetch" href="/rat-summ/assets/js/142.5012f6d5.js"><link rel="prefetch" href="/rat-summ/assets/js/143.c2dc2dce.js"><link rel="prefetch" href="/rat-summ/assets/js/144.3e4b75ec.js"><link rel="prefetch" href="/rat-summ/assets/js/145.13a8b399.js"><link rel="prefetch" href="/rat-summ/assets/js/146.70f5ac4b.js"><link rel="prefetch" href="/rat-summ/assets/js/147.0d5d58cd.js"><link rel="prefetch" href="/rat-summ/assets/js/148.aacf63f5.js"><link rel="prefetch" href="/rat-summ/assets/js/149.895e4fd8.js"><link rel="prefetch" href="/rat-summ/assets/js/15.fa4defba.js"><link rel="prefetch" href="/rat-summ/assets/js/150.4ae6eeac.js"><link rel="prefetch" href="/rat-summ/assets/js/151.f72a57b1.js"><link rel="prefetch" href="/rat-summ/assets/js/152.faa08a26.js"><link rel="prefetch" href="/rat-summ/assets/js/153.d874a8f1.js"><link rel="prefetch" href="/rat-summ/assets/js/154.35894c2e.js"><link rel="prefetch" href="/rat-summ/assets/js/155.df75c456.js"><link rel="prefetch" href="/rat-summ/assets/js/156.f67ffe52.js"><link rel="prefetch" href="/rat-summ/assets/js/157.6ba1aa39.js"><link rel="prefetch" href="/rat-summ/assets/js/158.f4e33392.js"><link rel="prefetch" href="/rat-summ/assets/js/159.0c1bf178.js"><link rel="prefetch" href="/rat-summ/assets/js/16.4204b333.js"><link rel="prefetch" href="/rat-summ/assets/js/160.b95cb57a.js"><link rel="prefetch" href="/rat-summ/assets/js/161.241b8b97.js"><link rel="prefetch" href="/rat-summ/assets/js/162.572fef13.js"><link rel="prefetch" href="/rat-summ/assets/js/163.1974ca32.js"><link rel="prefetch" href="/rat-summ/assets/js/164.abafb067.js"><link rel="prefetch" href="/rat-summ/assets/js/165.6cbad524.js"><link rel="prefetch" href="/rat-summ/assets/js/166.1543416f.js"><link rel="prefetch" href="/rat-summ/assets/js/167.f4fe7f3b.js"><link rel="prefetch" href="/rat-summ/assets/js/168.22ec85bc.js"><link rel="prefetch" href="/rat-summ/assets/js/169.9429ac16.js"><link rel="prefetch" href="/rat-summ/assets/js/17.d8b1fa06.js"><link rel="prefetch" href="/rat-summ/assets/js/170.5d21c313.js"><link rel="prefetch" href="/rat-summ/assets/js/171.fb97db6c.js"><link rel="prefetch" href="/rat-summ/assets/js/172.e77cdea4.js"><link rel="prefetch" href="/rat-summ/assets/js/173.c51a2877.js"><link rel="prefetch" href="/rat-summ/assets/js/174.b92338fb.js"><link rel="prefetch" href="/rat-summ/assets/js/175.21a40216.js"><link rel="prefetch" href="/rat-summ/assets/js/176.92cb0a5d.js"><link rel="prefetch" href="/rat-summ/assets/js/177.448bbbcc.js"><link rel="prefetch" href="/rat-summ/assets/js/178.a8821cec.js"><link rel="prefetch" href="/rat-summ/assets/js/179.a76ff9d0.js"><link rel="prefetch" href="/rat-summ/assets/js/18.d4717354.js"><link rel="prefetch" href="/rat-summ/assets/js/180.cb15b175.js"><link rel="prefetch" href="/rat-summ/assets/js/181.9ce44a33.js"><link rel="prefetch" href="/rat-summ/assets/js/182.87bdc2cd.js"><link rel="prefetch" href="/rat-summ/assets/js/183.7f53f4e2.js"><link rel="prefetch" href="/rat-summ/assets/js/184.a02c4c97.js"><link rel="prefetch" href="/rat-summ/assets/js/185.8f8339bc.js"><link rel="prefetch" href="/rat-summ/assets/js/186.7bb1d8fa.js"><link rel="prefetch" href="/rat-summ/assets/js/187.8cde5359.js"><link rel="prefetch" href="/rat-summ/assets/js/188.d0ce7168.js"><link rel="prefetch" href="/rat-summ/assets/js/189.e2779cc5.js"><link rel="prefetch" href="/rat-summ/assets/js/19.57c26288.js"><link rel="prefetch" href="/rat-summ/assets/js/190.e5aca8fb.js"><link rel="prefetch" href="/rat-summ/assets/js/191.cd004740.js"><link rel="prefetch" href="/rat-summ/assets/js/192.4f12a689.js"><link rel="prefetch" href="/rat-summ/assets/js/193.3142b310.js"><link rel="prefetch" href="/rat-summ/assets/js/194.da48a9af.js"><link rel="prefetch" href="/rat-summ/assets/js/195.1d836ffb.js"><link rel="prefetch" href="/rat-summ/assets/js/196.5ef7989a.js"><link rel="prefetch" href="/rat-summ/assets/js/197.95fca86a.js"><link rel="prefetch" href="/rat-summ/assets/js/198.a350b2a0.js"><link rel="prefetch" href="/rat-summ/assets/js/199.670ec80f.js"><link rel="prefetch" href="/rat-summ/assets/js/20.8859bdb4.js"><link rel="prefetch" href="/rat-summ/assets/js/200.5b2ec953.js"><link rel="prefetch" href="/rat-summ/assets/js/201.71e57c08.js"><link rel="prefetch" href="/rat-summ/assets/js/202.36fb732f.js"><link rel="prefetch" href="/rat-summ/assets/js/203.31661a65.js"><link rel="prefetch" href="/rat-summ/assets/js/204.9a60d991.js"><link rel="prefetch" href="/rat-summ/assets/js/205.0a0e0108.js"><link rel="prefetch" href="/rat-summ/assets/js/206.e9f0cb13.js"><link rel="prefetch" href="/rat-summ/assets/js/207.e76128c0.js"><link rel="prefetch" href="/rat-summ/assets/js/208.d4468295.js"><link rel="prefetch" href="/rat-summ/assets/js/209.364bffe5.js"><link rel="prefetch" href="/rat-summ/assets/js/21.13568c31.js"><link rel="prefetch" href="/rat-summ/assets/js/210.d7156634.js"><link rel="prefetch" href="/rat-summ/assets/js/211.3ef79707.js"><link rel="prefetch" href="/rat-summ/assets/js/212.025e8ca6.js"><link rel="prefetch" href="/rat-summ/assets/js/213.b9cf70b2.js"><link rel="prefetch" href="/rat-summ/assets/js/214.2aa87a38.js"><link rel="prefetch" href="/rat-summ/assets/js/215.587bd0f9.js"><link rel="prefetch" href="/rat-summ/assets/js/216.6bc7dd67.js"><link rel="prefetch" href="/rat-summ/assets/js/217.fd366d2d.js"><link rel="prefetch" href="/rat-summ/assets/js/218.c454be54.js"><link rel="prefetch" href="/rat-summ/assets/js/219.55c4ee1e.js"><link rel="prefetch" href="/rat-summ/assets/js/22.fe073a6b.js"><link rel="prefetch" href="/rat-summ/assets/js/220.a20bb37d.js"><link rel="prefetch" href="/rat-summ/assets/js/221.0da9bd73.js"><link rel="prefetch" href="/rat-summ/assets/js/222.acab6078.js"><link rel="prefetch" href="/rat-summ/assets/js/223.6e6eb503.js"><link rel="prefetch" href="/rat-summ/assets/js/224.e02e0947.js"><link rel="prefetch" href="/rat-summ/assets/js/225.77f856bc.js"><link rel="prefetch" href="/rat-summ/assets/js/226.ba95f314.js"><link rel="prefetch" href="/rat-summ/assets/js/227.48c32f3e.js"><link rel="prefetch" href="/rat-summ/assets/js/228.3afb056f.js"><link rel="prefetch" href="/rat-summ/assets/js/229.011c3b58.js"><link rel="prefetch" href="/rat-summ/assets/js/23.685f93c4.js"><link rel="prefetch" href="/rat-summ/assets/js/230.2a7d274b.js"><link rel="prefetch" href="/rat-summ/assets/js/231.0e58515a.js"><link rel="prefetch" href="/rat-summ/assets/js/232.12682cc5.js"><link rel="prefetch" href="/rat-summ/assets/js/233.4d9449cf.js"><link rel="prefetch" href="/rat-summ/assets/js/234.7e22495b.js"><link rel="prefetch" href="/rat-summ/assets/js/235.7d0e1160.js"><link rel="prefetch" href="/rat-summ/assets/js/236.b8eff948.js"><link rel="prefetch" href="/rat-summ/assets/js/237.9c084eab.js"><link rel="prefetch" href="/rat-summ/assets/js/238.a7b0885e.js"><link rel="prefetch" href="/rat-summ/assets/js/239.b6b058e4.js"><link rel="prefetch" href="/rat-summ/assets/js/24.fd7da72d.js"><link rel="prefetch" href="/rat-summ/assets/js/240.83d5e90d.js"><link rel="prefetch" href="/rat-summ/assets/js/241.a9666c7c.js"><link rel="prefetch" href="/rat-summ/assets/js/242.2f4a2d6f.js"><link rel="prefetch" href="/rat-summ/assets/js/243.31e04101.js"><link rel="prefetch" href="/rat-summ/assets/js/244.5a7bfc53.js"><link rel="prefetch" href="/rat-summ/assets/js/245.0a05d740.js"><link rel="prefetch" href="/rat-summ/assets/js/246.86375b20.js"><link rel="prefetch" href="/rat-summ/assets/js/247.e822fb19.js"><link rel="prefetch" href="/rat-summ/assets/js/248.57fd0c43.js"><link rel="prefetch" href="/rat-summ/assets/js/249.f855a118.js"><link rel="prefetch" href="/rat-summ/assets/js/25.8d7a4d93.js"><link rel="prefetch" href="/rat-summ/assets/js/250.b188c59d.js"><link rel="prefetch" href="/rat-summ/assets/js/251.7e4e84a2.js"><link rel="prefetch" href="/rat-summ/assets/js/252.2aafb779.js"><link rel="prefetch" href="/rat-summ/assets/js/253.b6ed4d32.js"><link rel="prefetch" href="/rat-summ/assets/js/254.ad7e4320.js"><link rel="prefetch" href="/rat-summ/assets/js/255.c3eff825.js"><link rel="prefetch" href="/rat-summ/assets/js/256.9b691409.js"><link rel="prefetch" href="/rat-summ/assets/js/257.f9a58366.js"><link rel="prefetch" href="/rat-summ/assets/js/258.32751d3a.js"><link rel="prefetch" href="/rat-summ/assets/js/259.87d453bf.js"><link rel="prefetch" href="/rat-summ/assets/js/26.ae598e4e.js"><link rel="prefetch" href="/rat-summ/assets/js/260.b1c3731c.js"><link rel="prefetch" href="/rat-summ/assets/js/261.581691bb.js"><link rel="prefetch" href="/rat-summ/assets/js/262.fdbb68aa.js"><link rel="prefetch" href="/rat-summ/assets/js/263.5eac7b08.js"><link rel="prefetch" href="/rat-summ/assets/js/264.3e5ae049.js"><link rel="prefetch" href="/rat-summ/assets/js/265.e560ba1a.js"><link rel="prefetch" href="/rat-summ/assets/js/266.cfb9cf35.js"><link rel="prefetch" href="/rat-summ/assets/js/267.071f13f9.js"><link rel="prefetch" href="/rat-summ/assets/js/268.8bb02241.js"><link rel="prefetch" href="/rat-summ/assets/js/269.e9ccb75e.js"><link rel="prefetch" href="/rat-summ/assets/js/27.62096338.js"><link rel="prefetch" href="/rat-summ/assets/js/270.00c21967.js"><link rel="prefetch" href="/rat-summ/assets/js/271.0ccdfdeb.js"><link rel="prefetch" href="/rat-summ/assets/js/272.9b16e71c.js"><link rel="prefetch" href="/rat-summ/assets/js/273.f21daf40.js"><link rel="prefetch" href="/rat-summ/assets/js/274.398de258.js"><link rel="prefetch" href="/rat-summ/assets/js/275.893610d6.js"><link rel="prefetch" href="/rat-summ/assets/js/276.6bc40456.js"><link rel="prefetch" href="/rat-summ/assets/js/277.055ecccd.js"><link rel="prefetch" href="/rat-summ/assets/js/278.8a5873ba.js"><link rel="prefetch" href="/rat-summ/assets/js/279.503d83fd.js"><link rel="prefetch" href="/rat-summ/assets/js/28.e9261df3.js"><link rel="prefetch" href="/rat-summ/assets/js/280.e9dacfee.js"><link rel="prefetch" href="/rat-summ/assets/js/281.d71b9f89.js"><link rel="prefetch" href="/rat-summ/assets/js/282.287947a4.js"><link rel="prefetch" href="/rat-summ/assets/js/283.ec30bb94.js"><link rel="prefetch" href="/rat-summ/assets/js/284.4456be87.js"><link rel="prefetch" href="/rat-summ/assets/js/285.451b948b.js"><link rel="prefetch" href="/rat-summ/assets/js/286.ac6bf1ef.js"><link rel="prefetch" href="/rat-summ/assets/js/287.c519acda.js"><link rel="prefetch" href="/rat-summ/assets/js/288.e3eaaf40.js"><link rel="prefetch" href="/rat-summ/assets/js/289.35035028.js"><link rel="prefetch" href="/rat-summ/assets/js/29.85b4b0dc.js"><link rel="prefetch" href="/rat-summ/assets/js/290.7af6c2bc.js"><link rel="prefetch" href="/rat-summ/assets/js/291.bdd53ac4.js"><link rel="prefetch" href="/rat-summ/assets/js/292.f5e294cf.js"><link rel="prefetch" href="/rat-summ/assets/js/293.b53f5815.js"><link rel="prefetch" href="/rat-summ/assets/js/294.e5b67d62.js"><link rel="prefetch" href="/rat-summ/assets/js/295.529c4257.js"><link rel="prefetch" href="/rat-summ/assets/js/296.1b0850c4.js"><link rel="prefetch" href="/rat-summ/assets/js/297.5d87f6a8.js"><link rel="prefetch" href="/rat-summ/assets/js/298.4281cee5.js"><link rel="prefetch" href="/rat-summ/assets/js/299.3a3e997c.js"><link rel="prefetch" href="/rat-summ/assets/js/3.30b0215d.js"><link rel="prefetch" href="/rat-summ/assets/js/30.51e6dc93.js"><link rel="prefetch" href="/rat-summ/assets/js/300.443491af.js"><link rel="prefetch" href="/rat-summ/assets/js/301.6627dcf9.js"><link rel="prefetch" href="/rat-summ/assets/js/302.91d574d8.js"><link rel="prefetch" href="/rat-summ/assets/js/303.7016c353.js"><link rel="prefetch" href="/rat-summ/assets/js/304.d550b266.js"><link rel="prefetch" href="/rat-summ/assets/js/305.bfbec795.js"><link rel="prefetch" href="/rat-summ/assets/js/306.abf09935.js"><link rel="prefetch" href="/rat-summ/assets/js/307.b61bee72.js"><link rel="prefetch" href="/rat-summ/assets/js/308.87f4b909.js"><link rel="prefetch" href="/rat-summ/assets/js/309.05bcfef5.js"><link rel="prefetch" href="/rat-summ/assets/js/31.c5cf586c.js"><link rel="prefetch" href="/rat-summ/assets/js/310.31a9cf03.js"><link rel="prefetch" href="/rat-summ/assets/js/311.10af3bf6.js"><link rel="prefetch" href="/rat-summ/assets/js/312.dff06896.js"><link rel="prefetch" href="/rat-summ/assets/js/313.1d6f347b.js"><link rel="prefetch" href="/rat-summ/assets/js/314.25dc4c41.js"><link rel="prefetch" href="/rat-summ/assets/js/315.ffebe23d.js"><link rel="prefetch" href="/rat-summ/assets/js/316.1ea82c7b.js"><link rel="prefetch" href="/rat-summ/assets/js/317.f9f265b8.js"><link rel="prefetch" href="/rat-summ/assets/js/318.157eefdc.js"><link rel="prefetch" href="/rat-summ/assets/js/319.5a9fb5af.js"><link rel="prefetch" href="/rat-summ/assets/js/320.37c1c2b9.js"><link rel="prefetch" href="/rat-summ/assets/js/321.e1933383.js"><link rel="prefetch" href="/rat-summ/assets/js/322.0ecd1f30.js"><link rel="prefetch" href="/rat-summ/assets/js/323.471e9f4d.js"><link rel="prefetch" href="/rat-summ/assets/js/324.fbffe746.js"><link rel="prefetch" href="/rat-summ/assets/js/325.4798848a.js"><link rel="prefetch" href="/rat-summ/assets/js/326.fe2830cc.js"><link rel="prefetch" href="/rat-summ/assets/js/327.98bd46ec.js"><link rel="prefetch" href="/rat-summ/assets/js/328.e3b29b8c.js"><link rel="prefetch" href="/rat-summ/assets/js/329.3a1e30b2.js"><link rel="prefetch" href="/rat-summ/assets/js/33.1745c30c.js"><link rel="prefetch" href="/rat-summ/assets/js/330.8a6caeab.js"><link rel="prefetch" href="/rat-summ/assets/js/331.ca734e5b.js"><link rel="prefetch" href="/rat-summ/assets/js/332.bb5c10d5.js"><link rel="prefetch" href="/rat-summ/assets/js/333.130f183d.js"><link rel="prefetch" href="/rat-summ/assets/js/334.502028e8.js"><link rel="prefetch" href="/rat-summ/assets/js/335.0aa30551.js"><link rel="prefetch" href="/rat-summ/assets/js/336.672cab22.js"><link rel="prefetch" href="/rat-summ/assets/js/337.a746a7bc.js"><link rel="prefetch" href="/rat-summ/assets/js/338.baf3f2a0.js"><link rel="prefetch" href="/rat-summ/assets/js/339.ace612b4.js"><link rel="prefetch" href="/rat-summ/assets/js/34.025cb969.js"><link rel="prefetch" href="/rat-summ/assets/js/340.12c28925.js"><link rel="prefetch" href="/rat-summ/assets/js/341.f84edde2.js"><link rel="prefetch" href="/rat-summ/assets/js/342.bd7812a1.js"><link rel="prefetch" href="/rat-summ/assets/js/343.2327936f.js"><link rel="prefetch" href="/rat-summ/assets/js/344.464252a5.js"><link rel="prefetch" href="/rat-summ/assets/js/345.93c67c54.js"><link rel="prefetch" href="/rat-summ/assets/js/346.08d8661c.js"><link rel="prefetch" href="/rat-summ/assets/js/347.4717d6b3.js"><link rel="prefetch" href="/rat-summ/assets/js/348.3abc0680.js"><link rel="prefetch" href="/rat-summ/assets/js/349.ae6c2429.js"><link rel="prefetch" href="/rat-summ/assets/js/35.8a35ddc4.js"><link rel="prefetch" href="/rat-summ/assets/js/350.0ced61f3.js"><link rel="prefetch" href="/rat-summ/assets/js/351.0ee534d4.js"><link rel="prefetch" href="/rat-summ/assets/js/352.76185971.js"><link rel="prefetch" href="/rat-summ/assets/js/353.a827393a.js"><link rel="prefetch" href="/rat-summ/assets/js/354.703e2f43.js"><link rel="prefetch" href="/rat-summ/assets/js/355.1c21cd7e.js"><link rel="prefetch" href="/rat-summ/assets/js/356.f5de7da2.js"><link rel="prefetch" href="/rat-summ/assets/js/357.44f38395.js"><link rel="prefetch" href="/rat-summ/assets/js/358.be391715.js"><link rel="prefetch" href="/rat-summ/assets/js/359.52e7ca03.js"><link rel="prefetch" href="/rat-summ/assets/js/36.ee87ddbc.js"><link rel="prefetch" href="/rat-summ/assets/js/360.2c475c66.js"><link rel="prefetch" href="/rat-summ/assets/js/361.3ca16ee4.js"><link rel="prefetch" href="/rat-summ/assets/js/362.6cbd67ed.js"><link rel="prefetch" href="/rat-summ/assets/js/363.c0c9d592.js"><link rel="prefetch" href="/rat-summ/assets/js/364.6c48ea1e.js"><link rel="prefetch" href="/rat-summ/assets/js/365.669d40d9.js"><link rel="prefetch" href="/rat-summ/assets/js/366.5cdd6960.js"><link rel="prefetch" href="/rat-summ/assets/js/367.5d81330a.js"><link rel="prefetch" href="/rat-summ/assets/js/368.66b4e165.js"><link rel="prefetch" href="/rat-summ/assets/js/369.c356b91b.js"><link rel="prefetch" href="/rat-summ/assets/js/37.05b6dead.js"><link rel="prefetch" href="/rat-summ/assets/js/370.26c815fc.js"><link rel="prefetch" href="/rat-summ/assets/js/371.defff585.js"><link rel="prefetch" href="/rat-summ/assets/js/372.219700c5.js"><link rel="prefetch" href="/rat-summ/assets/js/373.f87f3d8e.js"><link rel="prefetch" href="/rat-summ/assets/js/374.2fd577e9.js"><link rel="prefetch" href="/rat-summ/assets/js/375.3cb1dcfc.js"><link rel="prefetch" href="/rat-summ/assets/js/376.efa84bd2.js"><link rel="prefetch" href="/rat-summ/assets/js/377.52c66352.js"><link rel="prefetch" href="/rat-summ/assets/js/378.ab6f84aa.js"><link rel="prefetch" href="/rat-summ/assets/js/379.431fecfd.js"><link rel="prefetch" href="/rat-summ/assets/js/38.505a98a4.js"><link rel="prefetch" href="/rat-summ/assets/js/380.64869e20.js"><link rel="prefetch" href="/rat-summ/assets/js/381.bc2b123c.js"><link rel="prefetch" href="/rat-summ/assets/js/382.025e42e5.js"><link rel="prefetch" href="/rat-summ/assets/js/383.dec0d986.js"><link rel="prefetch" href="/rat-summ/assets/js/384.abf1ad8c.js"><link rel="prefetch" href="/rat-summ/assets/js/385.6d5c95f3.js"><link rel="prefetch" href="/rat-summ/assets/js/386.d971916b.js"><link rel="prefetch" href="/rat-summ/assets/js/387.36affe3c.js"><link rel="prefetch" href="/rat-summ/assets/js/388.1c6808b0.js"><link rel="prefetch" href="/rat-summ/assets/js/389.06fcd9f7.js"><link rel="prefetch" href="/rat-summ/assets/js/39.48b3dfb2.js"><link rel="prefetch" href="/rat-summ/assets/js/390.6302c8a9.js"><link rel="prefetch" href="/rat-summ/assets/js/391.9983a6dc.js"><link rel="prefetch" href="/rat-summ/assets/js/392.8f58781d.js"><link rel="prefetch" href="/rat-summ/assets/js/393.28ef587e.js"><link rel="prefetch" href="/rat-summ/assets/js/394.a77ab4ba.js"><link rel="prefetch" href="/rat-summ/assets/js/395.8bff5f43.js"><link rel="prefetch" href="/rat-summ/assets/js/396.31e18444.js"><link rel="prefetch" href="/rat-summ/assets/js/397.c12e8b8c.js"><link rel="prefetch" href="/rat-summ/assets/js/398.662fe63c.js"><link rel="prefetch" href="/rat-summ/assets/js/399.0db9725f.js"><link rel="prefetch" href="/rat-summ/assets/js/4.b03183cb.js"><link rel="prefetch" href="/rat-summ/assets/js/40.f000dcac.js"><link rel="prefetch" href="/rat-summ/assets/js/400.f3e95029.js"><link rel="prefetch" href="/rat-summ/assets/js/401.8d2a15bc.js"><link rel="prefetch" href="/rat-summ/assets/js/402.d3baeeb2.js"><link rel="prefetch" href="/rat-summ/assets/js/403.9ac2d5be.js"><link rel="prefetch" href="/rat-summ/assets/js/404.f2e0ac3d.js"><link rel="prefetch" href="/rat-summ/assets/js/405.c0333393.js"><link rel="prefetch" href="/rat-summ/assets/js/406.46d6afb9.js"><link rel="prefetch" href="/rat-summ/assets/js/407.f386a2ca.js"><link rel="prefetch" href="/rat-summ/assets/js/408.722c4018.js"><link rel="prefetch" href="/rat-summ/assets/js/409.7f3f374a.js"><link rel="prefetch" href="/rat-summ/assets/js/41.085c4bfa.js"><link rel="prefetch" href="/rat-summ/assets/js/410.6f7f46cb.js"><link rel="prefetch" href="/rat-summ/assets/js/411.7b6bb623.js"><link rel="prefetch" href="/rat-summ/assets/js/412.1c4e89f9.js"><link rel="prefetch" href="/rat-summ/assets/js/413.f3bd4510.js"><link rel="prefetch" href="/rat-summ/assets/js/414.ecde3b10.js"><link rel="prefetch" href="/rat-summ/assets/js/415.120c8d5e.js"><link rel="prefetch" href="/rat-summ/assets/js/416.b425e441.js"><link rel="prefetch" href="/rat-summ/assets/js/417.10022f9a.js"><link rel="prefetch" href="/rat-summ/assets/js/418.9b45086f.js"><link rel="prefetch" href="/rat-summ/assets/js/42.0a89f95d.js"><link rel="prefetch" href="/rat-summ/assets/js/43.f8bd27f5.js"><link rel="prefetch" href="/rat-summ/assets/js/44.34bbe27f.js"><link rel="prefetch" href="/rat-summ/assets/js/45.3acde343.js"><link rel="prefetch" href="/rat-summ/assets/js/46.62d91520.js"><link rel="prefetch" href="/rat-summ/assets/js/47.28552705.js"><link rel="prefetch" href="/rat-summ/assets/js/48.eb677d27.js"><link rel="prefetch" href="/rat-summ/assets/js/49.2008148b.js"><link rel="prefetch" href="/rat-summ/assets/js/5.55528c74.js"><link rel="prefetch" href="/rat-summ/assets/js/50.74365169.js"><link rel="prefetch" href="/rat-summ/assets/js/51.e3941e56.js"><link rel="prefetch" href="/rat-summ/assets/js/52.bfe9047a.js"><link rel="prefetch" href="/rat-summ/assets/js/53.e5c087bc.js"><link rel="prefetch" href="/rat-summ/assets/js/54.3d49dd74.js"><link rel="prefetch" href="/rat-summ/assets/js/55.fc8b058c.js"><link rel="prefetch" href="/rat-summ/assets/js/56.bd6512b3.js"><link rel="prefetch" href="/rat-summ/assets/js/57.5d51da6c.js"><link rel="prefetch" href="/rat-summ/assets/js/58.efe25a47.js"><link rel="prefetch" href="/rat-summ/assets/js/59.cb9015cb.js"><link rel="prefetch" href="/rat-summ/assets/js/6.ff530d99.js"><link rel="prefetch" href="/rat-summ/assets/js/60.d481bb6f.js"><link rel="prefetch" href="/rat-summ/assets/js/61.5bc85224.js"><link rel="prefetch" href="/rat-summ/assets/js/62.942ab118.js"><link rel="prefetch" href="/rat-summ/assets/js/63.d08359cb.js"><link rel="prefetch" href="/rat-summ/assets/js/64.d2a1069d.js"><link rel="prefetch" href="/rat-summ/assets/js/65.33f5cad9.js"><link rel="prefetch" href="/rat-summ/assets/js/66.738f34a5.js"><link rel="prefetch" href="/rat-summ/assets/js/67.0532cd2d.js"><link rel="prefetch" href="/rat-summ/assets/js/68.7d6ae148.js"><link rel="prefetch" href="/rat-summ/assets/js/69.dfbcd46e.js"><link rel="prefetch" href="/rat-summ/assets/js/7.dcb1dc1c.js"><link rel="prefetch" href="/rat-summ/assets/js/70.12f95662.js"><link rel="prefetch" href="/rat-summ/assets/js/71.738b5cbd.js"><link rel="prefetch" href="/rat-summ/assets/js/72.653ed5de.js"><link rel="prefetch" href="/rat-summ/assets/js/73.8bc69f34.js"><link rel="prefetch" href="/rat-summ/assets/js/74.f4889379.js"><link rel="prefetch" href="/rat-summ/assets/js/75.8530eac4.js"><link rel="prefetch" href="/rat-summ/assets/js/76.b952aea7.js"><link rel="prefetch" href="/rat-summ/assets/js/77.af1f4ad8.js"><link rel="prefetch" href="/rat-summ/assets/js/78.fe4470af.js"><link rel="prefetch" href="/rat-summ/assets/js/79.7539c952.js"><link rel="prefetch" href="/rat-summ/assets/js/8.6a6a21e7.js"><link rel="prefetch" href="/rat-summ/assets/js/80.8e8b4da0.js"><link rel="prefetch" href="/rat-summ/assets/js/81.3439878c.js"><link rel="prefetch" href="/rat-summ/assets/js/82.a9ee8aa8.js"><link rel="prefetch" href="/rat-summ/assets/js/83.70eb0a3e.js"><link rel="prefetch" href="/rat-summ/assets/js/84.179cc8fc.js"><link rel="prefetch" href="/rat-summ/assets/js/85.a6cee10b.js"><link rel="prefetch" href="/rat-summ/assets/js/86.5d3a42c6.js"><link rel="prefetch" href="/rat-summ/assets/js/87.fdae2c61.js"><link rel="prefetch" href="/rat-summ/assets/js/88.3b1a9c05.js"><link rel="prefetch" href="/rat-summ/assets/js/89.cd3cadf5.js"><link rel="prefetch" href="/rat-summ/assets/js/9.abbfe68b.js"><link rel="prefetch" href="/rat-summ/assets/js/90.1c8f120d.js"><link rel="prefetch" href="/rat-summ/assets/js/91.9169e692.js"><link rel="prefetch" href="/rat-summ/assets/js/92.a54885f4.js"><link rel="prefetch" href="/rat-summ/assets/js/93.ad139862.js"><link rel="prefetch" href="/rat-summ/assets/js/94.ea3f584f.js"><link rel="prefetch" href="/rat-summ/assets/js/95.91678324.js"><link rel="prefetch" href="/rat-summ/assets/js/97.3b75200f.js"><link rel="prefetch" href="/rat-summ/assets/js/98.52e4a976.js"><link rel="prefetch" href="/rat-summ/assets/js/99.3bbdf5fe.js">
    <link rel="stylesheet" href="/rat-summ/assets/css/0.styles.ea37c4a1.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/rat-summ/" class="home-link router-link-active"><img src="/rat-summ/img/logo.png" alt="写作认知体系" class="logo"> <span class="site-name can-hide">写作认知体系</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/rat-summ/" class="nav-link">首页</a></div><div class="nav-item"><a href="/rat-summ/writeRead/" class="nav-link">写作阅读</a></div><div class="nav-item"><a href="/rat-summ/promoteOper/" class="nav-link">推广运营</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="💖职场技能" class="dropdown-title"><a href="/rat-summ/workSkill/" class="link-title">💖职场技能</a> <span class="title" style="display:none;">💖职场技能</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/rat-summ/skill-note/" class="nav-link">技能记录</a></li><li class="dropdown-item"><!----> <a href="/rat-summ/skill-inter/" class="nav-link">面试技巧</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🌹快捷入口" class="dropdown-title"><!----> <span class="title" style="display:;">🌹快捷入口</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>快捷链接</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/rat-summ/pages/devLink/" class="nav-link">开发收藏</a></li></ul></li><li class="dropdown-item"><h4>💖体系入口</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="https://my.samyz.cn/rat-skill" target="_blank" rel="noopener noreferrer" class="nav-link external">
  工作实践体系
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://my.samyz.cn/rat-summ" target="_blank" rel="noopener noreferrer" class="nav-link external">
  写作认知体系
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://my.samyz.cn/rat-invest" target="_blank" rel="noopener noreferrer" class="nav-link external">
  投资理财体系
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li></ul></div></div> <a href="https://github.com/samyzh/rat-summ" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar" style="display:none;"><!----> <nav class="nav-links"><div class="nav-item"><a href="/rat-summ/" class="nav-link">首页</a></div><div class="nav-item"><a href="/rat-summ/writeRead/" class="nav-link">写作阅读</a></div><div class="nav-item"><a href="/rat-summ/promoteOper/" class="nav-link">推广运营</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="💖职场技能" class="dropdown-title"><a href="/rat-summ/workSkill/" class="link-title">💖职场技能</a> <span class="title" style="display:none;">💖职场技能</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/rat-summ/skill-note/" class="nav-link">技能记录</a></li><li class="dropdown-item"><!----> <a href="/rat-summ/skill-inter/" class="nav-link">面试技巧</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🌹快捷入口" class="dropdown-title"><!----> <span class="title" style="display:;">🌹快捷入口</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>快捷链接</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/rat-summ/pages/devLink/" class="nav-link">开发收藏</a></li></ul></li><li class="dropdown-item"><h4>💖体系入口</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="https://my.samyz.cn/rat-skill" target="_blank" rel="noopener noreferrer" class="nav-link external">
  工作实践体系
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://my.samyz.cn/rat-summ" target="_blank" rel="noopener noreferrer" class="nav-link external">
  写作认知体系
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://my.samyz.cn/rat-invest" target="_blank" rel="noopener noreferrer" class="nav-link external">
  投资理财体系
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li></ul></div></div> <a href="https://github.com/samyzh/rat-summ" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>my</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/rat-summ/pages/ddae31/" class="sidebar-link">自己认知</a></li><li><a href="/rat-summ/pages/3e4c45/" class="sidebar-link">总体部分</a></li><li><a href="/rat-summ/pages/e1f0b8/" class="sidebar-link">软技能</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>vue相关</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/rat-summ/pages/92d7a0/" class="sidebar-link">vue相关基础</a></li><li><a href="/rat-summ/pages/1869d3/" aria-current="page" class="active sidebar-link">vue相关汇总</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#vue-基础" class="sidebar-link">Vue 基础</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#vue的基本原理" class="sidebar-link">Vue的基本原理</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#双向数据绑定的原理" class="sidebar-link">双向数据绑定的原理</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#使用-object-defineproperty-来进行数据劫持有什么缺点" class="sidebar-link">使用 Object.defineProperty() 来进行数据劫持有什么缺点？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#mvvm和mvc的区别" class="sidebar-link">MVVM和MVC的区别</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#computed和watch的区别" class="sidebar-link">Computed和Watch的区别</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#computed-和-methods-的区别" class="sidebar-link">Computed 和 Methods 的区别</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#slot是什么-有什么作用-原理是什么" class="sidebar-link">slot是什么？有什么作用？原理是什么？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#过滤器的作用-如何实现一个过滤器" class="sidebar-link">过滤器的作用，如何实现一个过滤器</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#如何保存页面的当前的状态" class="sidebar-link">如何保存页面的当前的状态</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#常见的事件修饰符及其作用" class="sidebar-link">常见的事件修饰符及其作用</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#v-if、v-show、v-html-的原理" class="sidebar-link">v-if、v-show、v-html 的原理</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#v-if和v-show的区别" class="sidebar-link">v-if和v-show的区别</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#v-model-是如何实现的-语法糖实际是什么" class="sidebar-link">v-model 是如何实现的，语法糖实际是什么？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#v-model-可以被用在自定义组件上吗-如果可以-如何使用" class="sidebar-link">v-model 可以被用在自定义组件上吗？如果可以，如何使用？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#data为什么是一个函数而不是对象" class="sidebar-link">data为什么是一个函数而不是对象</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#对keep-alive的理解-它是如何实现的-具体缓存的是什么" class="sidebar-link">对keep-alive的理解，它是如何实现的，具体缓存的是什么？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#nexttick-原理及作用" class="sidebar-link">$nextTick 原理及作用</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#vue-中给-data-中的对象属性添加一个新的属性时会发生什么-如何解决" class="sidebar-link">Vue 中给 data 中的对象属性添加一个新的属性时会发生什么？如何解决？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#vue中封装的数组方法有哪些-其如何实现页面更新" class="sidebar-link">Vue中封装的数组方法有哪些，其如何实现页面更新</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#vue-单页应用与多页应用的区别" class="sidebar-link">Vue 单页应用与多页应用的区别</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#vue-template-到-render-的过程" class="sidebar-link">Vue template 到 render 的过程</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#vue-data-中某一个属性的值发生改变后-视图会立即同步执行重新渲染吗" class="sidebar-link">Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#简述-mixin、extends-的覆盖逻辑" class="sidebar-link">简述 mixin、extends 的覆盖逻辑</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#vue-原理" class="sidebar-link">Vue 原理</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#vue响应式" class="sidebar-link">Vue响应式</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#深度监听" class="sidebar-link">深度监听</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#虚拟dom-virtual-dom" class="sidebar-link">虚拟DOM（Virtual DOM）</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#diff-算法" class="sidebar-link">Diff 算法</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_25-描述下vue自定义指令" class="sidebar-link">25. 描述下Vue自定义指令</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_26-子组件可以直接改变父组件的数据吗" class="sidebar-link">26. 子组件可以直接改变父组件的数据吗？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_27-vue是如何收集依赖的" class="sidebar-link">27. Vue是如何收集依赖的？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_28-说一下对-react-和-vue-的理解-它们的异同" class="sidebar-link">28. 说一下对 React 和 Vue 的理解，它们的异同</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_29-vue的优点" class="sidebar-link">29. Vue的优点</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_30-assets和static的区别" class="sidebar-link">30. assets和static的区别</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_31-delete和vue-delete删除数组的区别" class="sidebar-link">31. delete和Vue.delete删除数组的区别</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_32-vue如何监听对象或者数组某个属性的变化" class="sidebar-link">32. vue如何监听对象或者数组某个属性的变化</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_33-什么是-mixin" class="sidebar-link">33. 什么是 mixin ？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_34-vue模版编译原理" class="sidebar-link">34. Vue模版编译原理</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_35-对ssr的理解" class="sidebar-link">35. 对SSR的理解</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_36-vue的性能优化有哪些" class="sidebar-link">36. Vue的性能优化有哪些</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_37-对-spa-单页面的理解-它的优缺点分别是什么" class="sidebar-link">37. 对 SPA 单页面的理解，它的优缺点分别是什么？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_38-template和jsx的有什么分别" class="sidebar-link">38. template和jsx的有什么分别？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_39-vue初始化页面闪动问题" class="sidebar-link">39. vue初始化页面闪动问题</a></li></ul></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_0-那你能讲一讲mvvm吗" class="sidebar-link">0.那你能讲一讲MVVM吗？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_1-简单说一下vue2-x响应式数据原理" class="sidebar-link">1.简单说一下Vue2.x响应式数据原理</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_2-那你知道vue3-x响应式数据原理吗" class="sidebar-link">2.那你知道Vue3.x响应式数据原理吗？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_3-再说一下vue2-x中如何监测数组变化" class="sidebar-link">3.再说一下vue2.x中如何监测数组变化</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_4-nexttick知道吗-实现原理是什么" class="sidebar-link">4.nextTick知道吗，实现原理是什么？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_5-说一下vue的生命周期" class="sidebar-link">5.说一下Vue的生命周期</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_6-你的接口请求一般放在哪个生命周期中" class="sidebar-link">6.你的接口请求一般放在哪个生命周期中？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_7-再说一下computed和watch" class="sidebar-link">7.再说一下Computed和Watch</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_8-说一下v-if和v-show的区别" class="sidebar-link">8.说一下v-if和v-show的区别</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_9-组件中的data为什么是一个函数" class="sidebar-link">9.组件中的data为什么是一个函数？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_10-说一下v-model的原理" class="sidebar-link">10.说一下v-model的原理</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_11-vue事件绑定原理说一下" class="sidebar-link">11.Vue事件绑定原理说一下</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_12-vue模版编译原理知道吗-能简单说一下吗" class="sidebar-link">12.Vue模版编译原理知道吗，能简单说一下吗？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_13-vue2-x和vue3-x渲染器的diff算法分别说一下" class="sidebar-link">13.Vue2.x和Vue3.x渲染器的diff算法分别说一下</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_14-再说一下虚拟dom以及key属性的作用" class="sidebar-link">14.再说一下虚拟Dom以及key属性的作用</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_15-keep-alive了解吗" class="sidebar-link">15.keep-alive了解吗</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_16-vue中组件生命周期调用顺序说一下" class="sidebar-link">16.Vue中组件生命周期调用顺序说一下</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#加载渲染过程" class="sidebar-link">加载渲染过程</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#子组件更新过程" class="sidebar-link">子组件更新过程</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#父组件更新过程" class="sidebar-link">父组件更新过程</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#销毁过程" class="sidebar-link">销毁过程</a></li></ul></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_17-vue2-x组件通信有哪些方式" class="sidebar-link">17.Vue2.x组件通信有哪些方式？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_18-ssr了解吗" class="sidebar-link">18.SSR了解吗？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_19-你都做过哪些vue的性能优化" class="sidebar-link">19.你都做过哪些Vue的性能优化？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#编码阶段" class="sidebar-link">编码阶段</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#seo优化" class="sidebar-link">SEO优化</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#打包优化" class="sidebar-link">打包优化</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#用户体验" class="sidebar-link">用户体验</a></li></ul></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_20-hash路由和history路由实现原理说一下" class="sidebar-link">20.hash路由和history路由实现原理说一下</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#生命周期" class="sidebar-link">生命周期</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_1-简单说一下vue的生命周期" class="sidebar-link">1. 简单说一下Vue的生命周期</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_2-vue-的父组件和子组件生命周期钩子执行顺序是什么" class="sidebar-link">2. Vue 的父组件和子组件生命周期钩子执行顺序是什么</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_3-vue-子组件和父组件执行顺序" class="sidebar-link">3. Vue 子组件和父组件执行顺序</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_4-created和mounted的区别" class="sidebar-link">4. created和mounted的区别</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_5-接口请求一般放在哪个生命周期中" class="sidebar-link">5. 接口请求一般放在哪个生命周期中？</a></li></ul></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#组件通信" class="sidebar-link">组件通信</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_1-props-emit" class="sidebar-link">（1） props  /  $emit</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_2-eventbus事件总线-emit-on" class="sidebar-link">（2）eventBus事件总线（$emit / $on）</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_3-依赖注入-project-inject" class="sidebar-link">（3）依赖注入（project / inject）</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_3-ref-refs" class="sidebar-link">（3）ref / refs</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_4-parent-children" class="sidebar-link">（4）$parent / $children</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_5-attrs-listeners" class="sidebar-link">（5）$attrs / $listeners</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_6-总结" class="sidebar-link">（6）总结</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#vue的优点" class="sidebar-link">vue的优点</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#请详细说下你对vue生命周期的理解" class="sidebar-link">请详细说下你对vue生命周期的理解？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#为什么vue组件中data必须是一个函数" class="sidebar-link">为什么vue组件中data必须是一个函数？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#vue中v-if和v-show有什么区别" class="sidebar-link">vue中v-if和v-show有什么区别？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#computed和watch的区别-2" class="sidebar-link">computed和watch的区别</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#vue-loader是什么-使用它的用途有哪些" class="sidebar-link">vue-loader是什么？使用它的用途有哪些？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#nexttick是什么" class="sidebar-link">$nextTick是什么？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#v-for-key的作用" class="sidebar-link">v-for key的作用</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#vue的双向数据绑定原理是什么" class="sidebar-link">Vue的双向数据绑定原理是什么？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#组件传值" class="sidebar-link">组件传值</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#prop-验证-和默认值" class="sidebar-link">prop 验证，和默认值</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#请说下封装-vue-组件的过程" class="sidebar-link">请说下封装 vue 组件的过程</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#vue-js的template编译" class="sidebar-link">Vue.js的template编译</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#scss是什么-在vue-cli中的安装使用步骤是-有哪几大特性" class="sidebar-link">scss是什么？在vue.cli中的安装使用步骤是？有哪几大特性？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#vue如何监听对象或者数组某个属性的变化" class="sidebar-link">vue如何监听对象或者数组某个属性的变化</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#常用的事件修饰符" class="sidebar-link">常用的事件修饰符</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#vue如何获取dom" class="sidebar-link">vue如何获取dom</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#v-on可以监听多个方法吗" class="sidebar-link">v-on可以监听多个方法吗？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#assets和static的区别" class="sidebar-link">assets和static的区别</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#slot插槽" class="sidebar-link">slot插槽</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#vue初始化页面闪动问题" class="sidebar-link">vue初始化页面闪动问题</a></li></ul></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#vue插件篇" class="sidebar-link">vue插件篇</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#状态管理-vuex" class="sidebar-link">状态管理（vuex）</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#路由页面管理-vue-router" class="sidebar-link">路由页面管理（vue-router）</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#网络请求-axios" class="sidebar-link">网络请求(axios)</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#视频播放-video-js" class="sidebar-link">视频播放(video.js)</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#vue常用ui库" class="sidebar-link">vue常用ui库</a></li></ul></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#常用webpack配置" class="sidebar-link">常用webpack配置</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#vue-lic3脚手架-vue-config-js" class="sidebar-link">vue-lic3脚手架（vue.config.js）</a></li></ul></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_1、说说你对-spa-单页面的理解-它的优缺点分别是什么" class="sidebar-link">1、说说你对 SPA 单页面的理解，它的优缺点分别是什么？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_2、v-show-与-v-if-有什么区别" class="sidebar-link">2、v-show 与 v-if 有什么区别？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_3、class-与-style-如何动态绑定" class="sidebar-link">3、Class 与 Style 如何动态绑定？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_4、怎样理解-vue-的单向数据流" class="sidebar-link">4、怎样理解 Vue 的单向数据流？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_5、computed-和-watch-的区别和运用的场景" class="sidebar-link">5、computed 和 watch 的区别和运用的场景？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_6、直接给一个数组项赋值-vue-能检测到变化吗" class="sidebar-link">6、直接给一个数组项赋值，Vue 能检测到变化吗？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_7、谈谈你对-vue-生命周期的理解" class="sidebar-link">7、谈谈你对 Vue 生命周期的理解？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_8、vue-的父组件和子组件生命周期钩子函数执行顺序" class="sidebar-link">8、Vue 的父组件和子组件生命周期钩子函数执行顺序？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_9、在哪个生命周期内调用异步请求" class="sidebar-link">9、在哪个生命周期内调用异步请求？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_10、在什么阶段才能访问操作dom" class="sidebar-link">10、在什么阶段才能访问操作DOM？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_11、父组件可以监听到子组件的生命周期吗" class="sidebar-link">11、父组件可以监听到子组件的生命周期吗？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_12、谈谈你对-keep-alive-的了解" class="sidebar-link">12、谈谈你对 keep-alive 的了解？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_13、组件中-data-为什么是一个函数" class="sidebar-link">13、组件中 data 为什么是一个函数？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_14、v-model-的原理" class="sidebar-link">14、v-model 的原理？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_15、vue-组件间通信有哪几种方式" class="sidebar-link">15、Vue 组件间通信有哪几种方式？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_16、你使用过-vuex-吗" class="sidebar-link">16、你使用过 Vuex 吗？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_17、使用过-vue-ssr-吗-说说-ssr" class="sidebar-link">17、使用过 Vue SSR 吗？说说 SSR？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_18、vue-router-路由模式有几种" class="sidebar-link">18、vue-router 路由模式有几种？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_19、能说下-vue-router-中常用的-hash-和-history-路由模式实现原理吗" class="sidebar-link">19、能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_20、什么是-mvvm" class="sidebar-link">20、什么是 MVVM？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_21、vue-是如何实现数据双向绑定的" class="sidebar-link">21、Vue 是如何实现数据双向绑定的？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_22、vue-框架怎么实现对象和数组的监听" class="sidebar-link">22、Vue 框架怎么实现对象和数组的监听？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_23、proxy-与-object-defineproperty-优劣对比" class="sidebar-link">23、Proxy 与 Object.defineProperty 优劣对比</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_24、vue-怎么用-vm-set-解决对象新增属性不能响应的问题" class="sidebar-link">24、Vue 怎么用 vm.$set() 解决对象新增属性不能响应的问题 ？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_25、虚拟-dom-的优缺点" class="sidebar-link">25、虚拟 DOM 的优缺点？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_26、虚拟-dom-实现原理" class="sidebar-link">26、虚拟 DOM 实现原理？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_27、vue-中的-key-有什么作用" class="sidebar-link">27、Vue 中的 key 有什么作用？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_28、你有对-vue-项目进行哪些优化" class="sidebar-link">28、你有对 Vue 项目进行哪些优化？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_29、对于即将到来的-vue3-0-特性你有什么了解的吗" class="sidebar-link">29、对于即将到来的 vue3.0 特性你有什么了解的吗？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#_30、说说你使用-vue-框架踩过最大的坑是什么-怎么解决的" class="sidebar-link">30、说说你使用 Vue 框架踩过最大的坑是什么？怎么解决的？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#来-先介绍一下vue的响应式系统" class="sidebar-link">来，先介绍一下Vue的响应式系统</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#computed与watch的区别" class="sidebar-link">computed与watch的区别</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#介绍一下vue的生命周期" class="sidebar-link">介绍一下Vue的生命周期</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#为什么组件的data必须是一个函数" class="sidebar-link">为什么组件的data必须是一个函数</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#组件之间是怎么通信的" class="sidebar-link">组件之间是怎么通信的</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#vue事件绑定原理说一下" class="sidebar-link">Vue事件绑定原理说一下</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#slot是什么-有什么作用-原理是什么-2" class="sidebar-link">slot是什么？有什么作用？原理是什么？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#vue模板渲染的原理是什么" class="sidebar-link">Vue模板渲染的原理是什么？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#template预编译是什么" class="sidebar-link">template预编译是什么？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#那template和jsx的有什么分别" class="sidebar-link">那template和jsx的有什么分别？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#说一下什么是virtual-dom" class="sidebar-link">说一下什么是Virtual DOM</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#介绍一下vue中的diff算法" class="sidebar-link">介绍一下Vue中的Diff算法</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#key属性的作用是什么" class="sidebar-link">key属性的作用是什么</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#说说vue2-0和vue3-0有什么区别" class="sidebar-link">说说Vue2.0和Vue3.0有什么区别</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#为什么要新增composition-api-它能解决什么问题" class="sidebar-link">为什么要新增Composition API，它能解决什么问题</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#都说composition-api与react-hook很像-说说区别" class="sidebar-link">都说Composition API与React Hook很像，说说区别</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#ssr有了解吗-原理是什么" class="sidebar-link">SSR有了解吗？原理是什么？</a></li><li class="sidebar-sub-header"><a href="/rat-summ/pages/1869d3/#参考链接" class="sidebar-link">参考链接</a></li></ul></li><li><a href="/rat-summ/pages/e9d2e4/" class="sidebar-link">vuex相关汇总</a></li><li><a href="/rat-summ/pages/6a181e/" class="sidebar-link">vue-router相关汇总</a></li><li><a href="/rat-summ/pages/vue2-zinter/" class="sidebar-link">vue2x题汇总及原理分析</a></li><li><a href="/rat-summ/pages/cb2c9d/" class="sidebar-link">vue3x面试题汇总及原理分析</a></li><li><a href="/rat-summ/pages/bd0191/" class="sidebar-link">vue其他相关题汇总</a></li><li><a href="/rat-summ/pages/a0970b/" class="sidebar-link">vue-router题汇总及原理分析</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>react相关</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/rat-summ/pages/566876/" class="sidebar-link">react相关基础</a></li><li><a href="/rat-summ/pages/efd0b7/" class="sidebar-link">react相关汇总</a></li><li><a href="/rat-summ/pages/cda868/" class="sidebar-link">react组件汇总</a></li><li><a href="/rat-summ/pages/a63427/" class="sidebar-link">redux_flux相关汇总</a></li><li><a href="/rat-summ/pages/ffb996/" class="sidebar-link">react路由相关汇总</a></li><li><a href="/rat-summ/pages/85c4ca/" class="sidebar-link">hooks相关汇总</a></li><li><a href="/rat-summ/pages/3ebf27/" class="sidebar-link">虚拟dom_fiber相关汇总</a></li><li><a href="/rat-summ/pages/907fde/" class="sidebar-link">react面试题汇总</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>工程化相关</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/rat-summ/pages/0ac51e/" class="sidebar-link">工程化相关基础</a></li><li><a href="/rat-summ/pages/f1db1d/" class="sidebar-link">webpack面试</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>协议相关</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/rat-summ/pages/19522b/" class="sidebar-link">网络相关基础</a></li><li><a href="/rat-summ/pages/e315e1/" class="sidebar-link">网络模型DNS_TCPIP相关汇总</a></li><li><a href="/rat-summ/pages/b6110a/" class="sidebar-link">http相关汇总</a></li><li><a href="/rat-summ/pages/fe5b8b/" class="sidebar-link">websocket相关汇总</a></li><li><a href="/rat-summ/pages/f4787f/" class="sidebar-link">mqtt相关汇总</a></li><li><a href="/rat-summ/pages/34a57f/" class="sidebar-link">安全相关汇总</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>js相关</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/rat-summ/pages/680db6/" class="sidebar-link">js相关基础</a></li><li><a href="/rat-summ/pages/bf84b5/" class="sidebar-link">js类型&amp;数组函数汇总</a></li><li><a href="/rat-summ/pages/755e9f/" class="sidebar-link">对象原型链及es6相关汇总</a></li><li><a href="/rat-summ/pages/f76f5b/" class="sidebar-link">事件及异步相关汇总</a></li><li><a href="/rat-summ/pages/80ebf3/" class="sidebar-link">手写及算法相关汇总</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>h5相关</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/rat-summ/pages/9a840f/" class="sidebar-link">h5相关基础</a></li><li><a href="/rat-summ/pages/ba8912/" class="sidebar-link">h5适配相关</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>算法&amp;设计模式</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/rat-summ/pages/482942/" class="sidebar-link">算法相关汇总</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>优化相关</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/rat-summ/pages/ef4a8f/" class="sidebar-link">前端性能优化相关汇总</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>算法</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/rat-summ/pages/98ce9e/" class="sidebar-link">高频算法题系列</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>部署相关</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/rat-summ/pages/286b5e/" class="sidebar-link">index</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>综合集训</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/rat-summ/pages/7ba1f8/" class="sidebar-link">刷题文章</a></li><li><a href="/rat-summ/pages/b8393d/" class="sidebar-link">面试题集训1</a></li><li><a href="/rat-summ/pages/2fd1d4/" class="sidebar-link">面试题集训2</a></li><li><a href="/rat-summ/pages/d9fe72/" class="sidebar-link">面试题集训3</a></li><li><a href="/rat-summ/pages/71cd80/" class="sidebar-link">面试题集训4</a></li><li><a href="/rat-summ/pages/aa4f5d/" class="sidebar-link">面试题集训5</a></li><li><a href="/rat-summ/pages/646933/" class="sidebar-link">面试题集训6</a></li><li><a href="/rat-summ/pages/4491ad/" class="sidebar-link">面试题集训7</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>android相关</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/rat-summ/pages/37a183/" class="sidebar-link">android面试</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>技能指南</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/rat-summ/pages/c9b4ac/" class="sidebar-link">面试重新梳理</a></li><li><a href="/rat-summ/pages/c487c5/" class="sidebar-link">面试校招基础</a></li><li><a href="/rat-summ/pages/9c7349/" class="sidebar-link">经验分享</a></li><li><a href="/rat-summ/pages/4f5eb9/" class="sidebar-link">前端面试必读文章</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>简历准备</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/rat-summ/pages/c57b12/" class="sidebar-link">简历准备</a></li></ul></section></li></ul> <div class="sidebar-slot sidebar-slot-bottom"><!-- 正方形 -->
      <ins class="adsbygoogle"
          style="display:block"
          data-ad-client="ca-pub-7828333725993554"
          data-ad-slot="3508773082"
          data-ad-format="auto"
          data-full-width-responsive="true"></ins>
      <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
      </script></div></aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-1cd794fe><div class="articleInfo" data-v-1cd794fe><ul class="breadcrumbs" data-v-1cd794fe><li data-v-1cd794fe><a href="/rat-summ/" title="首页" class="iconfont icon-home router-link-active" data-v-1cd794fe></a></li> <li data-v-1cd794fe><span data-v-1cd794fe>《面试技巧》</span></li> <li data-v-1cd794fe><span data-v-1cd794fe>vue相关</span></li> <!----></ul> <div class="info" data-v-1cd794fe><div title="作者" class="author iconfont icon-touxiang" data-v-1cd794fe><a href="https://github.com/samyzh" target="_blank" title="作者" class="beLink" data-v-1cd794fe>samy</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-1cd794fe><a href="javascript:;" data-v-1cd794fe>2021-06-25</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABGpJREFUSA3tVVtoXFUU3fvOI53UlmCaKIFmwEhsE7QK0ipFEdHEKpXaZGrp15SINsXUWvBDpBgQRKi0+KKoFeJHfZA+ED9KKoIU2gYD9UejTW4rVIzm0VSTziPzuNu1z507dibTTjL4U/DAzLn3nL3X2o91ziX6f9wMFdh6Jvbm9nNSV0msViVO6tN1Rm7NMu2OpeJ9lWBUTDxrJbYTS0hInuwciu9eLHlFxCLCZEk3MegsJmZ5K/JD6t7FkFdEvGUo1g7qJoG3MHImqRIn8/nzY1K9UPKKiJmtnUqHVE3Gbuay6vJE/N2FEmuxFjW2nUuE0yQXRRxLiTUAzs36zhZvOXJPdX850EVnnLZkB8prodQoM5JGj7Xk2mvC7JB8tG04Ef5PiXtG0UtxupRQSfTnBoCy554x18yJHI6I+G5Eru4LHmPJZEQsrvPUbMiA8G/WgMK7w7I+ez7++o2ANfbrjvaOl1tFMs+htG3IrZH9/hDX1Pr8Tc0UvH8tcX29KzAgIGcEkINyW5BF9x891hw6VYqgJHEk0huccS7vh3C6gTiODL+26huuBtbct8eZnqLML8PkxGYpuPZBqtqwkSjgc4mB5gbgig5i+y0UDK35LMxXisn9xQtK+nd26gTIHsHe/oblK/b29fUmN/8Y+9jAQrnBp56m1LcDlDp9irKTExSKduXJVWSqdBMA08pEJnEIOB3FPPMybu/oeV8zFeYN3xx576Q6RH+VmplE4ncQV5v+5rzSoyOU7PuEAg8g803PwBJ0CExno/jcMbN8tONYeOmHiuUNryvm3fRUy4tMPVLdAGkUhNWuggGrJcXPv+ouCjz0MKUHz1J2/E8IC9nqTabcxgaBYM0hPhD5Y65FsbxRQKxCQrDjDctW7PUM3HuZunFyifSAqEfuzCp48Il24luWUWZoyJCaPR82jE0+kFA643wRFVni4RYSq3ohJO2pZ7B5dO4xkDWbEpossJPLSrPjYID8rS2UHTlvyNxqIGsg674XJJ7vnh5L7PNwC4hh2sjCI96mzszOTpxLF0T7l88Yz7lAuK6OnL8gXLOnTvpzSb22YG8W7us3jSebFHeeqnXRG1vt+MoUM84LQIBmMsCTAcOauTh0T0l0neQK7m2bLMt2mGxU3HYssS0J2cdv5wljlPsrIuZLAG/2DOZIXgCYT8uMGZN+e2kSirfxZOPCsC0f24nTZzspnVn9VePS1Z5vubmAGGXG8ZFno9Hel0yfA5ZPhF7Dh972BQJ2qCpgH67lmWtBYbvk6sz02wjky2vXyz0XErP/kFB619js1BtwfOV4OPRqOQBjy3Qbk18vigUPPSD5ceHnwck7W9bhAqZdd7SuG7w4/P2F/GaJh8c7e9qgow+Q7cGBo+98WsLkuktFqiZabtXuQTu/Y5ETbR0v7tNSFnvrmu6pjdoan2KjMu8q/Hmj1EfCO2ZGfEIbIXKUlw8qaX9/b2oeSJmFksSeT/Fn0V3nSypChh4Gjh74ybO9aeZ/AN2dwciu2/MhAAAAAElFTkSuQmCC">
          vue相关汇总
        </h1>  <div class="theme-vdoing-content content__default"><p>title: vue相关汇总
date: 2021-03-27 11:02:25
permalink: /pages/57e70c/</p> <h2 id="vue-基础"><a href="#vue-基础" class="header-anchor">#</a> Vue 基础</h2> <h3 id="vue的基本原理"><a href="#vue的基本原理" class="header-anchor">#</a> Vue的基本原理</h3> <p>当一个Vue实例创建时，vue会遍历data选项的属性，用 Object.defineProperty（vue3.0使用proxy ）将它们转为 getter/setter 并且在内部追踪相关依赖，在属性被访问和修改时通知变化。 每个组件实例都有相应的 watcher程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。 <img src="/rat-summ/assets/img/eca9d99af4a749f485360bdb460a16e0~tplv-k3u1fbpfcp-zoom-1.83d7552d.png" alt="1ea415955f753356abe09214d31cac89.jpg"></p> <h3 id="双向数据绑定的原理"><a href="#双向数据绑定的原理" class="header-anchor">#</a> 双向数据绑定的原理</h3> <p>vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤：</p> <p>1、需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化</p> <p>2、compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</p> <p>3、Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: ①在自身实例化时往属性订阅器(dep)里面添加自己 ②自身必须有一个update()方法 ③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。</p> <p>4、MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</p> <h3 id="使用-object-defineproperty-来进行数据劫持有什么缺点"><a href="#使用-object-defineproperty-来进行数据劫持有什么缺点" class="header-anchor">#</a> 使用 Object.defineProperty() 来进行数据劫持有什么缺点？</h3> <p>有一些对属性的操作，使用这种方法无法拦截，比如说通过下标方式修改数组数据或者给对象新增属性，vue 内部通过重写函数解决了这个问题。在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为这是 ES6 的语法。</p> <h3 id="mvvm和mvc的区别"><a href="#mvvm和mvc的区别" class="header-anchor">#</a> MVVM和MVC的区别</h3> <p>MVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过分离关注点的方式来组织代码结构，优化我们的开发效率。 在开发单页面应用时，往往一个路由页面对应了一个脚本文件，所有的页面逻辑都在一个脚本文件里。页面的渲染、数据的获取，对用户事件的响应所有的应用逻辑都混合在一起，这样在开发简单项目时，可能看不出什么问题，当时一旦项目变得复杂，那么整个文件就会变得冗长，混乱，这样对我们的项目开发和后期的项目维护是非常不利的。</p> <p><strong>（1）MVC</strong></p> <p>MVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。其中 View 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。并且 View 和 Model 应用了观察者模式，当 Model 层发生改变的时候它会通知有关 View 层更新页面。Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。</p> <p><img src="/rat-summ/assets/img/c6ddddb2d42b45ba821168603d555470~tplv-k3u1fbpfcp-zoom-1.67acbfc9.png" alt="image.png"></p> <p>（2）MVVM</p> <p>MVVM 分为 Model、View、ViewModel 三者。</p> <ul><li>Model代表数据模型，数据和业务逻辑都在Model层中定义；</li> <li>View代表UI视图，负责数据的展示；</li> <li>ViewModel负责监听Model中数据的改变并且控制视图的更新，处理用 户交互操作；</li></ul> <p>Model和View并无直接关联，而是通过ViewModel来进行联系的，Model和ViewModel之间有着双向数据绑定的联系。因此当Model中 的数据改变时会触发View层的刷新，View中由于用户交互操作而改变的 数据也会在Model中同步。 这种模式实现了 Model和View的数据自动同步，因此开发者只需要专注 对数据的维护操作即可，而不需要自己操作DOM。</p> <p><img src="/rat-summ/assets/img/e02c8c1465e046a78d7690d8c1ccf0ac~tplv-k3u1fbpfcp-zoom-1.16f0c1c5.png" alt="image.png"></p> <p><strong>（2）MVP</strong></p> <p>MVP 模式与 MVC 唯一不同的在于 Presenter 和 Controller。在 MVC 模式中我们使用观察者模式，来实现当 Model 层数据发生变化的时候，通知 View 层的更新。这样 View 层和 Model 层耦合在一起，当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对代码的复用性造成一些问题。MVP 的模式通过使用 Presenter 来实现对 View 层和 Model 层的解耦。MVC 中的Controller 只知道 Model 的接口，因此它没有办法控制 View 层的更新，MVP 模式中，View 层的接口暴露给了 Presenter 因此我们可以在 Presenter 中将 Model 的变化和 View 的变化绑定在一起，以此来实现 View 和 Model 的同步更新。这样就实现了对 View 和 Model 的解耦，Presenter 还包含了其他的响应逻辑。</p> <h3 id="computed和watch的区别"><a href="#computed和watch的区别" class="header-anchor">#</a> Computed和Watch的区别</h3> <p><strong>对于Computed：</strong></p> <ul><li>它支持缓存，只有依赖的数据发生了变化，才会重新计算</li> <li>不支持异步，当Computed中有异步操作时，无法监听数据的变化</li> <li>computed的值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data声明过，或者父组件传递过来的props中的数据进行计算的。</li> <li>如果一个属性是由其他属性计算而来的，这个属性依赖其他的属性，一般会使用computed</li> <li>如果computed属性的属性值是函数，那么默认使用get方法，函数的返回值就是属性的属性值；在computed中，属性有一个get方法和一个set方法，当数据发生变化时，会调用set方法。</li></ul> <p><strong>对于Watch：</strong></p> <ul><li>它不支持缓存，数据变化时，它就会触发相应的操作</li> <li>支持异步监听</li> <li>监听的函数接收两个参数，第一个参数是最新的值，第二个是变化之前的值</li> <li>当一个属性发生变化时，就需要执行相应的操作</li> <li>监听数据必须是data中声明的或者父组件传递过来的props中的数据，当发生变化时，会出大其他操作，函数有两个的参数：
<ul><li>immediate：组件加载立即触发回调函数</li> <li>deep：深度监听，发现数据内部的变化，在复杂数据类型中使用，例如数组中的对象发生变化。需要注意的是，deep无法监听到数组和对象内部的变化。</li></ul></li></ul> <p>当想要执行异步或者昂贵的操作以响应不断的变化时，就需要使用watch。</p> <p><strong>总结：</strong></p> <ul><li>computed 计算属性 : 依赖其它属性值,并且 computed 的值有缓存,只有它依赖的 属性值发生改变,下一次获取 computed 的值时才会重新计算 computed 的值。</li> <li>watch 侦听器 : 更多的是<strong>观察</strong>的作用,<strong>无缓存性</strong>,类似于某些数据的监听回调,每 当监听的数据变化时都会执行回调进行后续操作。</li></ul> <p><strong>运用场景：</strong></p> <ul><li>当我们需要进行数值计算,并且依赖于其它数据时,应该使用 computed,因为可以利 用 computed 的缓存特性,避免每次获取值时,都要重新计算。</li> <li>当我们需要在数据变化时执行异步或开销较大的操作时,应该使用 watch,使用 watch 选项允许我们执行异步操作 ( 访问一个 API ),限制我们执行该操作的频率, 并在我们得到最终结果前,设置中间状态。这些都是计算属性无法做到的。</li></ul> <h3 id="computed-和-methods-的区别"><a href="#computed-和-methods-的区别" class="header-anchor">#</a> Computed 和 Methods 的区别</h3> <p>我们可以将同一函数定义为一个 method 或者一个计算属性。对于最终的结果，两种方式是相同的 <strong>不同点：</strong></p> <ul><li>computed: 计算属性是基于它们的依赖进行缓存的,只有在它的相关依赖发生改变时才会重新求值对于 method ，只要发生重新渲染，</li> <li>method 调用总会执行该函数</li></ul> <h3 id="slot是什么-有什么作用-原理是什么"><a href="#slot是什么-有什么作用-原理是什么" class="header-anchor">#</a> slot是什么？有什么作用？原理是什么？</h3> <p>slot又名插槽，是Vue的内容分发机制，组件内部的模板引擎使用slot元素作为承载分发内容的出口。插槽slot是子组件的一个模板标签元素，而这一个标签元素是否显示，以及怎么显示是由父组件决定的。slot又分三类，默认插槽，具名插槽和作用域插槽。</p> <ul><li>默认插槽：又名匿名查抄，当slot没有指定name属性值的时候一个默认显示插槽，一个组件内只有有一个匿名插槽。</li> <li>具名插槽：带有具体名字的插槽，也就是带有name属性的slot，一个组件可以出现多个具名插槽。</li> <li>作用域插槽：默认插槽、具名插槽的一个变体，可以是匿名插槽，也可以是具名插槽，该插槽的不同点是在子组件渲染作用域插槽时，可以将子组件内部的数据传递给父组件，让父组件根据子组件的传递过来的数据决定如何渲染该插槽。</li></ul> <p>实现原理：当子组件vm实例化时，获取到父组件传入的slot标签的内容，存放在<code>vm.$slot</code>中，默认插槽为<code>vm.$slot.default</code>，具名插槽为<code>vm.$slot.xxx</code>，xxx 为插槽名，当组件执行渲染函数时候，遇到slot标签，使用<code>$slot</code>中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可称该插槽为作用域插槽。</p> <h3 id="过滤器的作用-如何实现一个过滤器"><a href="#过滤器的作用-如何实现一个过滤器" class="header-anchor">#</a> 过滤器的作用，如何实现一个过滤器</h3> <p>根据过滤器的名称，过滤器是用来过滤数据的，在Vue中使用<code>filters</code>来过滤数据，<code>filters</code>不会修改数据，而是过滤数据，改变用户看到的输出（计算属性 <code>computed</code> ，方法 <code>methods</code> 都是通过修改数据来处理数据格式的输出显示）。</p> <p><strong>使用场景：</strong></p> <ul><li>需要格式化数据的情况，比如需要处理时间、价格等数据格式的输出 / 显示。</li> <li>比如后端返回一个 <strong>年月日的日期字符串</strong>，前端需要展示为 <strong>多少天前</strong> 的数据格式，此时就可以用我们的<code>fliters</code>过滤器来处理数据。</li></ul> <p>过滤器是一个函数，它会把表达式中的值始终当作函数的第一个参数。过滤器用在**插值表达式 **<code></code> 和 <code>v-bind</code>表达式中，然后放在操作符“ <strong><code>|</code></strong> ”后面进行指示。</p> <p>例如，在显示金额，给商品价格添加单位：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token operator">&lt;</span>li<span class="token operator">&gt;</span>商品价格：<span class="token punctuation">{</span><span class="token punctuation">{</span>item<span class="token punctuation">.</span>price <span class="token operator">|</span> filterPrice<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span>

 filters<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">filterPrice</span> <span class="token punctuation">(</span><span class="token parameter">price</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> price <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token string">'￥'</span> <span class="token operator">+</span> price<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token string">'--'</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="如何保存页面的当前的状态"><a href="#如何保存页面的当前的状态" class="header-anchor">#</a> 如何保存页面的当前的状态</h3> <p>既然是要保持页面的状态（其实也就是组件的状态），那么会出现以下两种情况：</p> <ul><li>前组件会被卸载</li> <li>前组件不会被卸载</li></ul> <p>那么可以按照这两种情况分别得到以下方法：</p> <p><strong>组件会被卸载：</strong></p> <p><strong>（1）将状态存储在LocalStorage / SessionStorage</strong></p> <p>只需要在组件即将被销毁的生命周期 <code>componentWillUnmount</code> （react）中在 LocalStorage / SessionStorage 中把当前组件的 state 通过 JSON.stringify() 储存下来就可以了。在这里面需要注意的是组件更新状态的时机。</p> <p>比如我们从 B 组件跳转到 A 组件的时候，A 组件需要更新自身的状态。但是如果我们从别的组件跳转到 B 组件的时候，实际上我们是希望 B 组件重新渲染的，也就是不要从 Storage 中读取信息。所以我们需要在 Storage 中的状态加入一个 flag 属性，用来控制 A 组件是否读取 Storage 中的状态。</p> <p><strong>优点</strong></p> <ul><li>兼容性好，不需要额外库或工具。</li> <li>简单快捷，基本可以满足大部分需求。</li></ul> <p><strong>缺点</strong></p> <ul><li>状态通过 JSON 方法储存（相当于深拷贝），如果状态中有特殊情况（比如 Date 对象、Regexp 对象等）的时候会得到字符串而不是原来的值。（具体参考用 JSON 深拷贝的缺点）</li> <li>如果 B 组件后退或者下一页跳转并不是前组件，那么 flag 判断会失效，导致从其他页面进入 A 组件页面时 A 组件会重新读取 Storage，会造成很奇怪的现象</li></ul> <p><strong>（2）路由传值</strong> 通过 react-router 的 Link 组件的 prop —— to 可以实现路由间传递参数的效果。</p> <p>在这里需要用到 state 参数，在 B 组件中通过 history.location.state 就可以拿到 state 值，保存它。返回 A 组件时再次携带 state 达到路由状态保持的效果。</p> <p><strong>优点</strong></p> <ul><li>简单快捷，不会污染 LocalStorage / SessionStorage。</li> <li>可以传递 Date、RegExp 等特殊对象（不用担心 JSON.stringify / parse 的不足）</li></ul> <p><strong>缺点</strong></p> <ul><li>如果 A 组件可以跳转至多个组件，那么在每一个跳转组件内都要写相同的逻辑。</li></ul> <p><strong>组件不会被卸载：</strong></p> <p><strong>（1）单页面渲染</strong> 要切换的组件作为子组件全屏渲染，父组件中正常储存页面状态。</p> <p><strong>优点</strong></p> <ul><li>代码量少</li> <li>不需要考虑状态传递过程中的错误</li></ul> <p><strong>缺点</strong></p> <ul><li>增加 A 组件维护成本</li> <li>需要传入额外的 prop 到 B 组件</li> <li>无法利用路由定位页面</li></ul> <p>除此之外，在Vue中，我们还可以是用keep-alive来缓存页面，当组件在keep-alive内被切换时组件的<strong>activated、deactivated</strong>这两个生命周期钩子函数会被执行 被包裹在keep-alive中的组件的状态将会被保留：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token operator">&lt;</span>keep<span class="token operator">-</span>alive<span class="token operator">&gt;</span>
	<span class="token operator">&lt;</span>router<span class="token operator">-</span>view v<span class="token operator">-</span><span class="token keyword">if</span><span class="token operator">=</span><span class="token string">&quot;$route.meta.keepAlive&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>view<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>kepp<span class="token operator">-</span>alive<span class="token operator">&gt;</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><strong>router.js</strong></p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token punctuation">{</span>
  path<span class="token operator">:</span> <span class="token string">'/'</span><span class="token punctuation">,</span>
  name<span class="token operator">:</span> <span class="token string">'xxx'</span><span class="token punctuation">,</span>
  <span class="token function-variable function">component</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'../src/views/xxx.vue'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  meta<span class="token operator">:</span><span class="token punctuation">{</span>
    keepAlive<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token comment">// 需要被缓存</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="常见的事件修饰符及其作用"><a href="#常见的事件修饰符及其作用" class="header-anchor">#</a> 常见的事件修饰符及其作用</h3> <ul><li><code>.stop</code>：等同于 JavaScript 中的 <code>event.stopPropagation()</code> ，防止事件冒泡；</li> <li><code>.prevent</code> ：等同于 JavaScript 中的 <code>event.preventDefault()</code> ，防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）；</li> <li><code>.capture</code> ：与事件冒泡的方向相反，事件捕获由外到内；</li> <li><code>.self</code> ：只会触发自己范围内的事件，不包含子元素；</li> <li><code>.once</code> ：只会触发一次。</li></ul> <h3 id="v-if、v-show、v-html-的原理"><a href="#v-if、v-show、v-html-的原理" class="header-anchor">#</a> v-if、v-show、v-html 的原理</h3> <ul><li>v-if会调用addIfCondition方法，生成vnode的时候会忽略对应节点，render的时候就不会渲染；</li> <li>v-show会生成vnode，render的时候也会渲染成真实节点，只是在render过程中会在节点的属性中修改show属性值，也就是常说的display；</li> <li>v-html会先移除节点下的所有节点，调用html方法，通过addProp添加innerHTML属性，归根结底还是设置innerHTML为v-html的值。</li></ul> <h3 id="v-if和v-show的区别"><a href="#v-if和v-show的区别" class="header-anchor">#</a> v-if和v-show的区别</h3> <ul><li><strong>手段</strong>：v-if是动态的向DOM树内添加或者删除DOM元素；v-show是通过设置DOM元素的display样式属性控制显隐；</li> <li><strong>编译过程</strong>：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换；</li> <li><strong>编译条件</strong>：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译; v-show是在任何条件下，无论首次条件是否为真，都被编译，然后被缓存，而且DOM元素保留；</li> <li><strong>性能消耗</strong>：v-if有更高的切换消耗；v-show有更高的初始渲染消耗；</li> <li><strong>使用场景</strong>：v-if适合运营条件不大可能改变；v-show适合频繁切换。</li></ul> <h3 id="v-model-是如何实现的-语法糖实际是什么"><a href="#v-model-是如何实现的-语法糖实际是什么" class="header-anchor">#</a> v-model 是如何实现的，语法糖实际是什么？</h3> <p><strong>（1）作用在表单元素上</strong> 动态绑定了 input 的 value 指向了 messgae 变量，并且在触发 input 事件的时候去动态把 message设置为目标值：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token operator">&lt;</span>input v<span class="token operator">-</span>model<span class="token operator">=</span><span class="token string">&quot;sth&quot;</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
<span class="token comment">//  等同于</span>
<span class="token operator">&lt;</span>input 
    v<span class="token operator">-</span>bind<span class="token operator">:</span>value<span class="token operator">=</span><span class="token string">&quot;message&quot;</span> 
    v<span class="token operator">-</span>on<span class="token operator">:</span>input<span class="token operator">=</span><span class="token string">&quot;message=$event.target.value&quot;</span>
<span class="token operator">&gt;</span>
<span class="token comment">//$event 指代当前触发的事件对象;</span>
<span class="token comment">//$event.target 指代当前触发的事件对象的dom;</span>
<span class="token comment">//$event.target.value 就是当前dom的value值;</span>
<span class="token comment">//在@input方法中，value =&gt; sth;</span>
<span class="token comment">//在:value中,sth =&gt; value;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p><strong>（2）作用在组件上</strong> 在自定义组件中，v-model 默认会利用名为 value 的 prop和名为 input 的事件</p> <p><strong>本质是一个父子组件通信的语法糖，通过prop和$.emit实现。</strong> 因此父组件 v-model 语法糖本质上可以修改为：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token operator">&lt;</span>child <span class="token operator">:</span>value<span class="token operator">=</span><span class="token string">&quot;message&quot;</span>  @input<span class="token operator">=</span><span class="token string">&quot;function(e){message = e}&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>child<span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>在组件的实现中，可以通过 v-model属性来配置子组件接收的prop名称，以及派发的事件名称。 例子：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 父组件</span>
<span class="token operator">&lt;</span>aa<span class="token operator">-</span>input v<span class="token operator">-</span>model<span class="token operator">=</span><span class="token string">&quot;aa&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>aa<span class="token operator">-</span>input<span class="token operator">&gt;</span>
<span class="token comment">// 等价于</span>
<span class="token operator">&lt;</span>aa<span class="token operator">-</span>input v<span class="token operator">-</span>bind<span class="token operator">:</span>value<span class="token operator">=</span><span class="token string">&quot;aa&quot;</span> v<span class="token operator">-</span>on<span class="token operator">:</span>input<span class="token operator">=</span><span class="token string">&quot;aa=$event.target.value&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>aa<span class="token operator">-</span>input<span class="token operator">&gt;</span>

<span class="token comment">// 子组件：</span>
<span class="token operator">&lt;</span>input v<span class="token operator">-</span>bind<span class="token operator">:</span>value<span class="token operator">=</span><span class="token string">&quot;aa&quot;</span> v<span class="token operator">-</span>on<span class="token operator">:</span>input<span class="token operator">=</span><span class="token string">&quot;onmessage&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>aa<span class="token operator">-</span>input<span class="token operator">&gt;</span>

props<span class="token operator">:</span><span class="token punctuation">{</span>value<span class="token operator">:</span>aa<span class="token punctuation">,</span><span class="token punctuation">}</span>
methods<span class="token operator">:</span><span class="token punctuation">{</span>
    <span class="token function">onmessage</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'input'</span><span class="token punctuation">,</span>e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>默认情况下，一个组件上的v-model 会把 value 用作 prop且把 input 用作 event。但是一些输入类型比如单选框和复选框按钮可能想使用 value prop 来达到不同的目的。使用 model 选项可以回避这些情况产生的冲突。js 监听input 输入框输入数据改变，用oninput，数据改变以后就会立刻出发这个事件。通过input事件把数据emit出去，在父组件接受。父组件设置v−model的值为inputemit 出去，在父组件接受。父组件设置v-model的值为input emit出去，在父组件接受。父组件设置v−model的值为inputemit过来的值。</p> <h3 id="v-model-可以被用在自定义组件上吗-如果可以-如何使用"><a href="#v-model-可以被用在自定义组件上吗-如果可以-如何使用" class="header-anchor">#</a> v-model 可以被用在自定义组件上吗？如果可以，如何使用？</h3> <p>可以。v-model 实际上是一个语法糖，如：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token operator">&lt;</span>input v<span class="token operator">-</span>model<span class="token operator">=</span><span class="token string">&quot;searchText&quot;</span><span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>实际上相当于：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token operator">&lt;</span>input
  v<span class="token operator">-</span>bind<span class="token operator">:</span>value<span class="token operator">=</span><span class="token string">&quot;searchText&quot;</span>
  v<span class="token operator">-</span>on<span class="token operator">:</span>input<span class="token operator">=</span><span class="token string">&quot;searchText = $event.target.value&quot;</span>
<span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>用在自定义组件上也是同理：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token operator">&lt;</span>custom<span class="token operator">-</span>input v<span class="token operator">-</span>model<span class="token operator">=</span><span class="token string">&quot;searchText&quot;</span><span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>相当于：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token operator">&lt;</span>custom<span class="token operator">-</span>input
  v<span class="token operator">-</span>bind<span class="token operator">:</span>value<span class="token operator">=</span><span class="token string">&quot;searchText&quot;</span>
  v<span class="token operator">-</span>on<span class="token operator">:</span>input<span class="token operator">=</span><span class="token string">&quot;searchText = $event&quot;</span>
<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>custom<span class="token operator">-</span>input<span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>显然，custom-input 与父组件的交互如下：</p> <ol><li>父组件将<code>searchText</code>变量传入custom-input 组件，使用的 prop 名为<code>value</code>；</li> <li>custom-input 组件向父组件传出名为<code>input</code>的事件，父组件将接收到的值赋值给<code>searchText</code>；</li></ol> <p>所以，custom-input 组件的实现应该类似于这样：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code>Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'custom-input'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  props<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'value'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
    &lt;input
      v-bind:value=&quot;value&quot;
      v-on:input=&quot;$emit('input', $event.target.value)&quot;
    &gt;
  </span><span class="token template-punctuation string">`</span></span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="data为什么是一个函数而不是对象"><a href="#data为什么是一个函数而不是对象" class="header-anchor">#</a> data为什么是一个函数而不是对象</h3> <p>JavaScript中的<strong>对象是引用类型的数据</strong>，当多个实例引用同一个对象时，只要一个实例对这个对象进行操作，其他实例中的数据也会发生变化。</p> <p>而在Vue中，我们更多的是想要复用组件，<strong>那就需要每个组件都有自己的数据，这样组件之间才不会相互干扰。</strong></p> <p>所以组件的数据不能写成对象的形式，而是要写成函数的形式。数据以函数返回值的形式定义，<strong>这样当我们每次复用组件的时候，就会返回一个新的data，也就是说每个组件都有自己的私有数据空间</strong>，它们各自维护自己的数据，不会干扰其他组件的正常运行。</p> <h3 id="对keep-alive的理解-它是如何实现的-具体缓存的是什么"><a href="#对keep-alive的理解-它是如何实现的-具体缓存的是什么" class="header-anchor">#</a> 对keep-alive的理解，它是如何实现的，具体缓存的是什么？</h3> <p>如果需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 keep-alive 组件包裹需要保存的组件。</p> <p><strong>（1）keep-alive</strong> keep-alive有以下三个属性：</p> <ul><li>include 字符串或正则表达式，只有名称匹配的组件会被匹配</li> <li>exclude 字符串或正则表达式。任何名称匹配的组件都不会被缓存。</li> <li>max 数字。最多可以缓存多少组件实例</li></ul> <p>注意：keep-alive 包裹动态组件时，会缓存不活动的组件实例</p> <p><strong>主要流程</strong></p> <ol><li>判断组件 name ，不在 include 或者在 exclude 中，直接返回 vnode，说明该组件不被缓存。</li> <li>获取组件实例 key ，如果有获取实例的 key，否则重新生成。</li> <li>key生成规则，cid +&quot;∶∶&quot;+ tag ，仅靠cid是不够的，因为相同的构造函数可以注册为不同的本地组件。</li> <li>如果缓存对象内存在，则直接从缓存对象中获取组件实例给 vnode ，不存在则添加到缓存对象中。</li> <li>最大缓存数量，当缓存组件数量超过 max 值时，清除 keys 数组内第一个组件。</li></ol> <p><strong>（2）keep-alive 的实现</strong></p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> patternTypes<span class="token operator">:</span> Array<span class="token operator">&lt;</span>Function<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">[</span>String<span class="token punctuation">,</span> RegExp<span class="token punctuation">,</span> Array<span class="token punctuation">]</span> <span class="token comment">// 接收：字符串，正则，数组</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">'keep-alive'</span><span class="token punctuation">,</span>
  abstract<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">// 抽象组件，是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。</span>
  props<span class="token operator">:</span> <span class="token punctuation">{</span>
    include<span class="token operator">:</span> patternTypes<span class="token punctuation">,</span> <span class="token comment">// 匹配的组件，缓存</span>
    exclude<span class="token operator">:</span> patternTypes<span class="token punctuation">,</span> <span class="token comment">// 不去匹配的组件，不缓存</span>
    max<span class="token operator">:</span> <span class="token punctuation">[</span>String<span class="token punctuation">,</span> Number<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">// 缓存组件的最大实例数量, 由于缓存的是组件实例（vnode），数量过多的时候，会占用过多的内存，可以用max指定上限</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>

  <span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 用于初始化缓存虚拟DOM数组和vnode的key</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>cache <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>keys <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>

  <span class="token function">destroyed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 销毁缓存cache的组件实例</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> <span class="token keyword">this</span><span class="token punctuation">.</span>cache<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">pruneCacheEntry</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>cache<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>keys<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>

  <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// prune 削减精简[v.]</span>
    <span class="token comment">// 去监控include和exclude的改变，根据最新的include和exclude的内容，来实时削减缓存的组件的内容</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$watch</span><span class="token punctuation">(</span><span class="token string">'include'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">pruneCache</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">matches</span><span class="token punctuation">(</span>val<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$watch</span><span class="token punctuation">(</span><span class="token string">'exclude'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">pruneCache</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token operator">!</span><span class="token function">matches</span><span class="token punctuation">(</span>val<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><p><strong>render函数</strong></p> <ol><li>会在 keep-alive 组件内部去写自己的内容，所以可以去获取默认 slot 的内容，然后根据这个去获取组件</li> <li>keep-alive 只对第一个组件有效，所以获取第一个子组件。</li> <li>和 keep-alive 搭配使用的一般有：动态组件 和router-view</li></ol> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token function">render</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//</span>
  <span class="token keyword">function</span> <span class="token function">getFirstComponentChild</span> <span class="token punctuation">(</span><span class="token parameter">children<span class="token operator">:</span> <span class="token operator">?</span>Array<span class="token operator">&lt;</span>VNode<span class="token operator">&gt;</span></span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token operator">?</span>VNode <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> children<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> c <span class="token operator">=</span> children<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>componentOptions<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">isAsyncPlaceholder</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> c
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> slot <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$slots<span class="token punctuation">.</span>default <span class="token comment">// 获取默认插槽</span>
  <span class="token keyword">const</span> vnode<span class="token operator">:</span> VNode <span class="token operator">=</span> <span class="token function">getFirstComponentChild</span><span class="token punctuation">(</span>slot<span class="token punctuation">)</span><span class="token comment">// 获取第一个子组件</span>
  <span class="token keyword">const</span> componentOptions<span class="token operator">:</span> <span class="token operator">?</span>VNodeComponentOptions <span class="token operator">=</span> vnode <span class="token operator">&amp;&amp;</span> vnode<span class="token punctuation">.</span>componentOptions <span class="token comment">// 组件参数</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>componentOptions<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 是否有组件参数</span>
    <span class="token comment">// check pattern</span>
    <span class="token keyword">const</span> name<span class="token operator">:</span> <span class="token operator">?</span>string <span class="token operator">=</span> <span class="token function">getComponentName</span><span class="token punctuation">(</span>componentOptions<span class="token punctuation">)</span> <span class="token comment">// 获取组件名</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> include<span class="token punctuation">,</span> exclude <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>
      <span class="token comment">// not included</span>
      <span class="token punctuation">(</span>include <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">!</span>name <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">matches</span><span class="token punctuation">(</span>include<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">||</span>
      <span class="token comment">// excluded</span>
      <span class="token punctuation">(</span>exclude <span class="token operator">&amp;&amp;</span> name <span class="token operator">&amp;&amp;</span> <span class="token function">matches</span><span class="token punctuation">(</span>exclude<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 如果不匹配当前组件的名字和include以及exclude</span>
      <span class="token comment">// 那么直接返回组件的实例</span>
      <span class="token keyword">return</span> vnode
    <span class="token punctuation">}</span>

    <span class="token keyword">const</span> <span class="token punctuation">{</span> cache<span class="token punctuation">,</span> keys <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span>

    <span class="token comment">// 获取这个组件的key</span>
    <span class="token keyword">const</span> key<span class="token operator">:</span> <span class="token operator">?</span>string <span class="token operator">=</span> vnode<span class="token punctuation">.</span>key <span class="token operator">==</span> <span class="token keyword">null</span>
      <span class="token comment">// same constructor may get registered as different local components</span>
      <span class="token comment">// so cid alone is not enough (#3269)</span>
      <span class="token operator">?</span> componentOptions<span class="token punctuation">.</span>Ctor<span class="token punctuation">.</span>cid <span class="token operator">+</span> <span class="token punctuation">(</span>componentOptions<span class="token punctuation">.</span>tag <span class="token operator">?</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">::</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>componentOptions<span class="token punctuation">.</span>tag<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span> <span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">)</span>
      <span class="token operator">:</span> vnode<span class="token punctuation">.</span>key

    <span class="token keyword">if</span> <span class="token punctuation">(</span>cache<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// LRU缓存策略执行</span>
      vnode<span class="token punctuation">.</span>componentInstance <span class="token operator">=</span> cache<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">.</span>componentInstance <span class="token comment">// 组件初次渲染的时候componentInstance为undefined</span>

      <span class="token comment">// make current key freshest</span>
      <span class="token function">remove</span><span class="token punctuation">(</span>keys<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
      keys<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
      <span class="token comment">// 根据LRU缓存策略执行，将key从原来的位置移除，然后将这个key值放到最后面</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 在缓存列表里面没有的话，则加入，同时判断当前加入之后，是否超过了max所设定的范围，如果是，则去除</span>
      <span class="token comment">// 使用时间间隔最长的一个</span>
      cache<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> vnode
      keys<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
      <span class="token comment">// prune oldest entry</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>max <span class="token operator">&amp;&amp;</span> keys<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>max<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">pruneCacheEntry</span><span class="token punctuation">(</span>cache<span class="token punctuation">,</span> keys<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> keys<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_vnode<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 将组件的keepAlive属性设置为true</span>
    vnode<span class="token punctuation">.</span>data<span class="token punctuation">.</span>keepAlive <span class="token operator">=</span> <span class="token boolean">true</span> <span class="token comment">// 作用：判断是否要执行组件的created、mounted生命周期函数</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> vnode <span class="token operator">||</span> <span class="token punctuation">(</span>slot <span class="token operator">&amp;&amp;</span> slot<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br></div></div><p>keep-alive 具体是通过 cache 数组缓存所有组件的 vnode 实例。当 cache 内原有组件被使用时会将该组件 key 从 keys 数组中删除，然后 push 到 keys数组最后，以便清除最不常用组件。</p> <p><strong>步骤总结</strong></p> <ol><li>获取 keep-alive 下第一个子组件的实例对象，通过他去获取这个组件的组件名</li> <li>通过当前组件名去匹配原来 include 和 exclude，判断当前组件是否需要缓存，不需要缓存，直接返回当前组件的实例vNode</li> <li>需要缓存，判断他当前是否在缓存数组里面：</li></ol> <ul><li>存在，则将他原来位置上的 key 给移除，同时将这个组件的 key 放到数组最后面（LRU）</li> <li>不存在，将组件 key 放入数组，然后判断当前 key数组是否超过 max 所设置的范围，超过，那么削减未使用时间最长的一个组件的 key</li></ul> <ol><li>最后将这个组件的 keepAlive 设置为 true</li></ol> <p><strong>（3）keep-alive 本身的创建过程和 patch 过程</strong></p> <p>缓存渲染的时候，会根据 vnode.componentInstance（首次渲染 vnode.componentInstance 为 undefned） 和 keepAlive 属性判断不会执行组件的 created、mounted 等钩子函数，而是对缓存的组件执行 patch 过程∶ 直接把缓存的 DOM 对象直接插入到目标元素中，完成了数据更新的情况下的渲染过程。</p> <p><strong>首次渲染</strong></p> <ul><li>组件的首次渲染∶判断组件的 abstract 属性，才往父组件里面挂载 DOM</li></ul> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// core/instance/lifecycle</span>
<span class="token keyword">function</span> <span class="token function">initLifecycle</span> <span class="token punctuation">(</span><span class="token parameter">vm<span class="token operator">:</span> Component</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> options <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options

  <span class="token comment">// locate first non-abstract parent</span>
  <span class="token keyword">let</span> parent <span class="token operator">=</span> options<span class="token punctuation">.</span>parent
  <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>options<span class="token punctuation">.</span>abstract<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 判断组件的abstract属性，才往父组件里面挂载DOM</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>parent<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>abstract <span class="token operator">&amp;&amp;</span> parent<span class="token punctuation">.</span>$parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      parent <span class="token operator">=</span> parent<span class="token punctuation">.</span>$parent
    <span class="token punctuation">}</span>
    parent<span class="token punctuation">.</span>$children<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  vm<span class="token punctuation">.</span>$parent <span class="token operator">=</span> parent
  vm<span class="token punctuation">.</span>$root <span class="token operator">=</span> parent <span class="token operator">?</span> parent<span class="token punctuation">.</span>$root <span class="token operator">:</span> vm

  vm<span class="token punctuation">.</span>$children <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  vm<span class="token punctuation">.</span>$refs <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  vm<span class="token punctuation">.</span>_watcher <span class="token operator">=</span> <span class="token keyword">null</span>
  vm<span class="token punctuation">.</span>_inactive <span class="token operator">=</span> <span class="token keyword">null</span>
  vm<span class="token punctuation">.</span>_directInactive <span class="token operator">=</span> <span class="token boolean">false</span>
  vm<span class="token punctuation">.</span>_isMounted <span class="token operator">=</span> <span class="token boolean">false</span>
  vm<span class="token punctuation">.</span>_isDestroyed <span class="token operator">=</span> <span class="token boolean">false</span>
  vm<span class="token punctuation">.</span>_isBeingDestroyed <span class="token operator">=</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><ul><li>判断当前 keepAlive 和 componentInstance 是否存在来判断是否要执行组件 prepatch 还是执行创建 componentlnstance</li></ul> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// core/vdom/create-component</span>
<span class="token function">init</span> <span class="token punctuation">(</span>vnode<span class="token operator">:</span> VNodeWithData<span class="token punctuation">,</span> hydrating<span class="token operator">:</span> boolean<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token operator">?</span>boolean <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>
      vnode<span class="token punctuation">.</span>componentInstance <span class="token operator">&amp;&amp;</span>
      <span class="token operator">!</span>vnode<span class="token punctuation">.</span>componentInstance<span class="token punctuation">.</span>_isDestroyed <span class="token operator">&amp;&amp;</span>
      vnode<span class="token punctuation">.</span>data<span class="token punctuation">.</span>keepAlive
    <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// componentInstance在初次是undefined!!!</span>
      <span class="token comment">// kept-alive components, treat as a patch</span>
      <span class="token keyword">const</span> mountedNode<span class="token operator">:</span> any <span class="token operator">=</span> vnode <span class="token comment">// work around flow</span>
      componentVNodeHooks<span class="token punctuation">.</span><span class="token function">prepatch</span><span class="token punctuation">(</span>mountedNode<span class="token punctuation">,</span> mountedNode<span class="token punctuation">)</span> <span class="token comment">// prepatch函数执行的是组件更新的过程</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> child <span class="token operator">=</span> vnode<span class="token punctuation">.</span>componentInstance <span class="token operator">=</span> <span class="token function">createComponentInstanceForVnode</span><span class="token punctuation">(</span>
        vnode<span class="token punctuation">,</span>
        activeInstance
      <span class="token punctuation">)</span>
      child<span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span>hydrating <span class="token operator">?</span> vnode<span class="token punctuation">.</span>elm <span class="token operator">:</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> hydrating<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>prepatch 操作就不会在执行组件的 mounted 和 created 生命周期函数，而是直接将 DOM 插入</p> <p><strong>（4）LRU （least recently used）缓存策略</strong> LRU 缓存策略∶ 从内存中找出最久未使用的数据并置换新的数据。 LRU（Least rencently used）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是 <strong>&quot;如果数据最近被访问过，那么将来被访问的几率也更高&quot;</strong>。 最常见的实现是使用一个链表保存缓存数据，详细算法实现如下∶</p> <ul><li>新数据插入到链表头部</li> <li>每当缓存命中（即缓存数据被访问），则将数据移到链表头部</li> <li>链表满的时候，将链表尾部的数据丢弃。</li></ul> <h3 id="nexttick-原理及作用"><a href="#nexttick-原理及作用" class="header-anchor">#</a> $nextTick 原理及作用</h3> <p>Vue 的 nextTick 其本质是对 JavaScript 执行原理 EventLoop 的一种应用。</p> <p>nextTick 的核心是利用了如 Promise 、MutationObserver、setImmediate、setTimeout的原生 JavaScript 方法来模拟对应的微/宏任务的实现，本质是为了利用 JavaScript 的这些异步回调任务队列来实现 Vue 框架中自己的异步回调队列。</p> <p>nextTick 不仅是 Vue 内部的异步队列的调用方法，同时也允许开发者在实际项目中使用这个方法来满足实际应用中对 DOM 更新数据时机的后续逻辑处理</p> <p>nextTick 是典型的将底层 JavaScript 执行原理应用到具体案例中的示例，引入异步更新队列机制的原因∶</p> <ul><li>如果是同步更新，则多次对一个或多个属性赋值，会频繁触发 UI/DOM 的渲染，可以减少一些无用渲染</li> <li>同时由于 VirtualDOM 的引入，每一次状态发生变化后，状态变化的信号会发送给组件，组件内部使用 VirtualDOM 进行计算得出需要更新的具体的 DOM 节点，然后对 DOM 进行更新操作，每次更新状态后的渲染过程需要更多的计算，而这种无用功也将浪费更多的性能，所以异步渲染变得更加至关重要</li></ul> <p>Vue采用了数据驱动视图的思想，但是我们在一些情况下，仍然需要操作DOM。有时候，我们可能遇到这样的情况，DOM1的数据发生了变化，而DOM2需要从DOM1中获取数据，那这时就会发现DOM2的视图并没有更新，这时就需要用到了<code>nextTick</code>了。 由于Vue的DOM操作是异步的，所以，在上面的情况中，就要将DOM2获取数据的操作写在<code>$nextTick</code>中。</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获取数据的操作...</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>所以，<strong>在以下情况下，会用到nextTick</strong>：</p> <ul><li>在数据变化后执行的某个操作，而这个操作需要使用随数据变化而变化的DOM结构的时候，这个操作就需要方法在<code>nextTick()</code>的回调函数中。</li> <li>在vue生命周期中，如果在created()钩子进行DOM操作，也一定要放在<code>nextTick()</code>的回调函数中。</li></ul> <p>因为在created()钩子函数中，页面的DOM还未渲染，这时候也没办法操作DOM，所以，此时如果想要操作DOM，必须将操作的代码放在<code>nextTick()</code>的回调函数中。</p> <h3 id="vue-中给-data-中的对象属性添加一个新的属性时会发生什么-如何解决"><a href="#vue-中给-data-中的对象属性添加一个新的属性时会发生什么-如何解决" class="header-anchor">#</a> <strong>Vue 中给 data 中的对象属性添加一个新的属性时会发生什么？如何解决？</strong></h3> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token operator">&lt;</span>template<span class="token operator">&gt;</span> 
   <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>ul<span class="token operator">&gt;</span>
         <span class="token operator">&lt;</span>li v<span class="token operator">-</span><span class="token keyword">for</span><span class="token operator">=</span><span class="token string">&quot;value in obj&quot;</span> <span class="token operator">:</span>key<span class="token operator">=</span><span class="token string">&quot;value&quot;</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">{</span>value<span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span> 
      <span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">&gt;</span> 
      <span class="token operator">&lt;</span>button @click<span class="token operator">=</span><span class="token string">&quot;addObjB&quot;</span><span class="token operator">&gt;</span>添加 obj<span class="token punctuation">.</span>b<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span> 
   <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">&gt;</span>

<span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
    <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span> 
       <span class="token function">data</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
          <span class="token keyword">return</span> <span class="token punctuation">{</span> 
              obj<span class="token operator">:</span> <span class="token punctuation">{</span> 
                  a<span class="token operator">:</span> <span class="token string">'obj.a'</span> 
              <span class="token punctuation">}</span> 
          <span class="token punctuation">}</span> 
       <span class="token punctuation">}</span><span class="token punctuation">,</span>
       methods<span class="token operator">:</span> <span class="token punctuation">{</span> 
          <span class="token function">addObjB</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
              <span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token string">'obj.b'</span> 
              console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">)</span> 
          <span class="token punctuation">}</span> 
      <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p>点击 button 会发现，obj.b 已经成功添加，但是视图并未刷新。这是因为在Vue实例创建时，obj.b并未声明，因此就没有被Vue转换为响应式的属性，自然就不会触发视图的更新，这时就需要使用Vue的全局 api <strong>$set()：</strong></p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token function">addObjB</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>
   <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'obj.b'</span><span class="token punctuation">)</span>
   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>$set()方法相当于手动的去把obj.b处理成一个响应式的属性，此时视图也会跟着改变了。</p> <h3 id="vue中封装的数组方法有哪些-其如何实现页面更新"><a href="#vue中封装的数组方法有哪些-其如何实现页面更新" class="header-anchor">#</a> Vue中封装的数组方法有哪些，其如何实现页面更新</h3> <p>在Vue中，对响应式处理利用的是Object.defineProperty对数据进行拦截，而这个方法并不能监听到数组内部变化，数组长度变化，数组的截取变化等，所以我们需要对这些操作进行hack，让Vue能监听到其中的变化。</p> <p><img src="/rat-summ/assets/img/7524c7357fc543aba98b0731bfa4a176~tplv-k3u1fbpfcp-zoom-1.9083b74d.png" alt="image.png"> 那Vue是如何实现让这些数组方法实现元素的实时更新的呢，下面是Vue中对这些方法的封装：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 缓存数组原型</span>
<span class="token keyword">const</span> arrayProto <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
<span class="token comment">// 实现 arrayMethods.__proto__ === Array.prototype</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> arrayMethods <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>arrayProto<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 需要进行功能拓展的方法</span>
<span class="token keyword">const</span> methodsToPatch <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token string">&quot;push&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;pop&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;shift&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;unshift&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;splice&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;sort&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;reverse&quot;</span>
<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * Intercept mutating methods and emit events
 */</span>
methodsToPatch<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">method</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 缓存原生数组方法</span>
  <span class="token keyword">const</span> original <span class="token operator">=</span> arrayProto<span class="token punctuation">[</span>method<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token function">def</span><span class="token punctuation">(</span>arrayMethods<span class="token punctuation">,</span> method<span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token function">mutator</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 执行并缓存原生数组功能</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">original</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 响应式处理</span>
    <span class="token keyword">const</span> ob <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>__ob__<span class="token punctuation">;</span>
    <span class="token keyword">let</span> inserted<span class="token punctuation">;</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>method<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// push、unshift会新增索引，所以要手动observer</span>
      <span class="token keyword">case</span> <span class="token string">&quot;push&quot;</span><span class="token operator">:</span>
      <span class="token keyword">case</span> <span class="token string">&quot;unshift&quot;</span><span class="token operator">:</span>
        inserted <span class="token operator">=</span> args<span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token comment">// splice方法，如果传入了第三个参数，也会有索引加入，也要手动observer。</span>
      <span class="token keyword">case</span> <span class="token string">&quot;splice&quot;</span><span class="token operator">:</span>
        inserted <span class="token operator">=</span> args<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// </span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>inserted<span class="token punctuation">)</span> ob<span class="token punctuation">.</span><span class="token function">observeArray</span><span class="token punctuation">(</span>inserted<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 获取插入的值，并设置响应式监听</span>
    <span class="token comment">// notify change</span>
    ob<span class="token punctuation">.</span>dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 通知依赖更新</span>
    <span class="token comment">// 返回原生数组方法的执行结果</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br></div></div><p>简单来说就是，重写了数组中的那些原生方法，首先获取到这个数组的__ob__，也就是它的Observer对象，如果有新的值，就调用observeArray继续对新的值观察变化（也就是通过<code>target__proto__ == arrayMethods</code>来改变了数组实例的型），然后手动调用notify，通知渲染watcher，执行update。</p> <h3 id="vue-单页应用与多页应用的区别"><a href="#vue-单页应用与多页应用的区别" class="header-anchor">#</a> Vue 单页应用与多页应用的区别</h3> <p><strong>概念：</strong></p> <ul><li>SPA单页面应用（SinglePage Web Application），指只有一个主页面的应用，一开始只需要加载一次js、css等相关资源。所有内容都包含在主页面，对每一 个功能模块组件化。单页应用跳转，就是切换相关组件，仅仅刷新局部资源。</li> <li>MPA多页面应用 （MultiPage Application），指有多个独立页面的应用，每个页面必须重复加载js、css等相关资源。 多页应用跳转，需要整页资源刷新。</li></ul> <p>区别： <img src="/rat-summ/assets/img/783d6be21d414d31af1cbc3cf2254f58~tplv-k3u1fbpfcp-zoom-1.d16fe403.png" alt="775316ebb4c727f7c8771cc2c06e06dd.jpg"></p> <h3 id="vue-template-到-render-的过程"><a href="#vue-template-到-render-的过程" class="header-anchor">#</a> Vue template 到 render 的过程</h3> <p>vue的模版编译过程主要如下：<strong>template -&gt; ast -&gt; render函数</strong></p> <p>vue 在模版编译版本的码中会执行 compileToFunctions 将template转化为render函数：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 将模板编译为render函数</span>
<span class="token keyword">const</span> <span class="token punctuation">{</span> render<span class="token punctuation">,</span> staticRenderFns <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">compileToFunctions</span><span class="token punctuation">(</span>template<span class="token punctuation">,</span>options<span class="token comment">//省略}, this)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>CompileToFunctions中的主要逻辑如下∶</p> <p><strong>（1）调用parse方法将template转化为ast（抽象语法树）</strong></p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code>constast <span class="token operator">=</span> <span class="token function">parse</span><span class="token punctuation">(</span>template<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> options<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li><strong>parse的目标</strong>：把tamplate转换为AST树，它是一种用 JavaScript对象的形式来描述整个模板。</li> <li><strong>解析过程</strong>：利用正则表达式顺序解析模板，当解析到开始标签、闭合标签、文本的时候都会分别执行对应的 回调函数，来达到构造AST树的目的。</li></ul> <p>AST元素节点总共三种类型：type为1表示普通元素、2为表达式、3为纯文本 ** <strong>（2）对静态节点做优化</strong></p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token function">optimize</span><span class="token punctuation">(</span>ast<span class="token punctuation">,</span>options<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这个过程主要分析出哪些是静态节点，给其打一个标记，为后续更新渲染可以直接跳过静态节点做优化</p> <p>深度遍历AST，查看每个子树的节点元素是否为静态节点或者静态节点根。如果为静态节点，他们生成的DOM永远不会改变，这对运行时模板更新起到了极大的优化作用。</p> <p><strong>（3）生成代码</strong></p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> code <span class="token operator">=</span> <span class="token function">generate</span><span class="token punctuation">(</span>ast<span class="token punctuation">,</span> options<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>generate将ast抽象语法树编译成 render字符串并将静态部分放到 staticRenderFns 中，最后通过 <code>new Function(`` render``)</code> 生成render函数。</p> <h3 id="vue-data-中某一个属性的值发生改变后-视图会立即同步执行重新渲染吗"><a href="#vue-data-中某一个属性的值发生改变后-视图会立即同步执行重新渲染吗" class="header-anchor">#</a> Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？</h3> <p>不会立即同步执行重新渲染。 Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。 Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化， Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。</p> <p>如果同一个watcher被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。 然后，在下一个的事件循环&quot;tick&quot;中，Vue 刷新队列并执行实际（已去重的）工作。</p> <h3 id="简述-mixin、extends-的覆盖逻辑"><a href="#简述-mixin、extends-的覆盖逻辑" class="header-anchor">#</a> 简述 mixin、extends 的覆盖逻辑</h3> <p><strong>（1）mixin 和 extends</strong> mixin 和 extends均是用于合并、拓展组件的，两者均通过 mergeOptions 方法实现合并。</p> <ul><li>mixins 接收一个混入对象的数组，其中混入对象可以像正常的实例对象一样包含实例选项，这些选项会被合并到最终的选项中。Mixin 钩子按照传入顺序依次调用，并在调用组件自身的钩子之前被调用。</li> <li>extends 主要是为了便于扩展单文件组件，接收一个对象或构造函数。</li></ul> <p><img src="/rat-summ/assets/img/c8012ae1591345f7a8b8da3254b72005~tplv-k3u1fbpfcp-zoom-1.2d885133.png" alt="bb253b1d177f421741af0e7dd0f52b5e.jpg"> <strong>（2）mergeOptions 的执行过程</strong></p> <ul><li>规范化选项（normalizeProps、normalizelnject、normalizeDirectives)</li> <li>对未合并的选项，进行判断</li></ul> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>child<span class="token punctuation">.</span>_base<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>child<span class="token punctuation">.</span>extends<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        parent <span class="token operator">=</span> <span class="token function">mergeOptions</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> child<span class="token punctuation">.</span>extends<span class="token punctuation">,</span> vm<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>child<span class="token punctuation">.</span>mixins<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">=</span> child<span class="token punctuation">.</span>mixins<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            parent <span class="token operator">=</span> <span class="token function">mergeOptions</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> child<span class="token punctuation">.</span>mixins<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> vm<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><ul><li>合并处理。根据一个通用 Vue 实例所包含的选项进行分类逐一判断合并，如 props、data、 methods、watch、computed、生命周期等，将合并结果存储在新定义的 options 对象里。</li> <li>返回合并结果 options。</li></ul> <h3 id="vue-原理"><a href="#vue-原理" class="header-anchor">#</a> Vue 原理</h3> <p>数据驱动视图（MVVM, setState），Vue MVVM （ Model + View + ViewModel ）</p> <p><img src="/rat-summ/assets/img/image-20210427193126917.1b1c601c.png" alt="image-20210427193126917"></p> <h3 id="vue响应式"><a href="#vue响应式" class="header-anchor">#</a> Vue响应式</h3> <p>组件 data 的数据一旦变化，立刻触发视图的更新，实现数据驱动视图的第一步</p> <blockquote><p>核心API：Object.defineProperty，Object.defineProperty 有一些缺点，Vue3.0 开始启用 Proxy， Proxy有兼容性问题，且无法 polyfill（兼容性问题解决方案）</p></blockquote> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// Object.defineProperty 基础使用</span>
<span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token string">'Actoress'</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token string">&quot;name&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'get'</span><span class="token punctuation">)</span>
       <span class="token keyword">return</span> name
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function-variable function">set</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">newValue</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'set'</span><span class="token punctuation">)</span>
        name <span class="token operator">=</span> newValue
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 调用</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment">// get() 执行 =&gt; 'Actoress'</span>
data<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'samy'</span> <span class="token comment">// set() 执行</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><h3 id="深度监听"><a href="#深度监听" class="header-anchor">#</a> 深度监听</h3> <ul><li><strong>深度监听，需要递归到底，一次性计算量大</strong></li> <li><strong>无法监听新增属性/删除属性</strong></li> <li><strong>数组需要重新定义数组原型</strong></li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 触发更新视图</span>
<span class="token keyword">function</span> <span class="token function">updateView</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'视图更新'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 重新定义数组原型</span>
<span class="token keyword">const</span> oldArrayProperty <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype
<span class="token comment">// 创建新对象，原型指向 oldArrayProperty ，再扩展新的方法不会影响原型</span>
<span class="token keyword">const</span> arrProto <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>oldArrayProperty<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">[</span><span class="token string">'push'</span><span class="token punctuation">,</span> <span class="token string">'pop'</span><span class="token punctuation">,</span> <span class="token string">'shift'</span><span class="token punctuation">,</span> <span class="token string">'unshift'</span><span class="token punctuation">,</span> <span class="token string">'splice'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">methodName</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
   arrProto<span class="token punctuation">[</span>methodName<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token function">updateView</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 触发视图更新</span>
       oldArrayProperty<span class="token punctuation">[</span>methodName<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token operator">...</span>arguments<span class="token punctuation">)</span>
       <span class="token comment">// Array.prototype.push.call(this, ...arguments)</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 重新定义属性，监听起来</span>
<span class="token keyword">function</span> <span class="token function">defineReactive</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token function">observer</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token comment">// 深度监听</span>

   <span class="token comment">// 核心 API</span>
   Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>
       <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token keyword">return</span> value
       <span class="token punctuation">}</span><span class="token punctuation">,</span>
       <span class="token function">set</span><span class="token punctuation">(</span>newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token keyword">if</span> <span class="token punctuation">(</span>newValue <span class="token operator">!==</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
               <span class="token function">observer</span><span class="token punctuation">(</span>newValue<span class="token punctuation">)</span><span class="token comment">// 深度监听</span>
               <span class="token comment">// 设置新值</span>
               <span class="token comment">// 注意，value 一直在闭包中，此处设置完之后，再 get 时也是会获取最新的值</span>
               value <span class="token operator">=</span> newValue
               <span class="token function">updateView</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 触发更新视图</span>
           <span class="token punctuation">}</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 监听对象属性</span>
<span class="token keyword">function</span> <span class="token function">observer</span><span class="token punctuation">(</span><span class="token parameter">target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> target <span class="token operator">!==</span> <span class="token string">'object'</span> <span class="token operator">||</span> target <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">return</span> target <span class="token comment">// 不是对象或数组</span>
   <span class="token punctuation">}</span>
   <span class="token comment">// 不能写在这里，这样会污染全局的 Array 原型</span>
   <span class="token comment">// Array.prototype.push = function () {</span>
   <span class="token comment">//     updateView()</span>
   <span class="token comment">//     ...</span>
   <span class="token comment">// }</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       target<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> arrProto
   <span class="token punctuation">}</span>
   <span class="token comment">// 重新定义各个属性（for in 也可以遍历数组）</span>
   <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token function">defineReactive</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> target<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 准备数据</span>
<span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token punctuation">{</span>
   name<span class="token operator">:</span> <span class="token string">'Actoress'</span><span class="token punctuation">,</span>
   age<span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span>
   info<span class="token operator">:</span> <span class="token punctuation">{</span>
       address<span class="token operator">:</span> <span class="token string">'北京'</span> <span class="token comment">// 需要深度监听</span>
   <span class="token punctuation">}</span><span class="token punctuation">,</span>
   nums<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>

<span class="token comment">// 监听数据</span>
<span class="token function">observer</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>

<span class="token comment">// 测试</span>
<span class="token comment">// data.name = 'samy'</span>
<span class="token comment">// data.age = 21</span>
<span class="token comment">// // console.log('age', data.age)</span>
<span class="token comment">// data.x = '100' // 新增属性，监听不到 —— 所以有 Vue.set</span>
<span class="token comment">// delete data.name // 删除属性，监听不到 —— 所有已 Vue.delete</span>
<span class="token comment">// data.info.address = '上海' // 深度监听</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br></div></div><h3 id="虚拟dom-virtual-dom"><a href="#虚拟dom-virtual-dom" class="header-anchor">#</a> 虚拟DOM（Virtual DOM）</h3> <p>vdom 是实现 Vue 和 React 的重要基石
为什么会有 vdom</p> <ul><li>有了一定复杂度，想减少计算次数比较难</li> <li>能不能把计算，更多的转移到JS计算？因为JS执行速度很快</li> <li>vdom 用 JS 模拟 DOM 结构，计算出最小的变更，操作DOM</li></ul> <h4 id="用js模拟dom结构"><a href="#用js模拟dom结构" class="header-anchor">#</a> 用JS模拟DOM结构</h4> <p><img src="/rat-summ/assets/img/image-20210427193245820.660e85b7.png" alt="image-20210427193245820"></p> <h4 id="使用-snabbdom-操作虚拟-dom"><a href="#使用-snabbdom-操作虚拟-dom" class="header-anchor">#</a> 使用 snabbdom 操作虚拟 dom</h4> <p>文档：<a href="https://github.com/snabbdom/snabbdom" target="_blank" rel="noopener noreferrer">github.com/snabbdom/sn…<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>
主要API <code>h()</code> &amp;&amp; <code>vnode</code> &amp;&amp; <code>patch()</code></p> <h3 id="diff-算法"><a href="#diff-算法" class="header-anchor">#</a> Diff 算法</h3> <ul><li>diff 算法是 vdom 中最核心、最关键的部分</li> <li>diff 算法能在日常使用 Vue React 中体现出来（循环的 key）</li></ul> <h4 id="优化前-树-diff-的时间复杂度-n-3"><a href="#优化前-树-diff-的时间复杂度-n-3" class="header-anchor">#</a> 优化前 树 diff 的时间复杂度 (n^3)</h4> <ol><li>遍历Tree1，遍历Tree2</li> <li>排序</li> <li>假设有1000个节点，就要计算1亿次，算法不可用</li></ol> <h4 id="优化后时间复杂度-n-1"><a href="#优化后时间复杂度-n-1" class="header-anchor">#</a> 优化后时间复杂度 (n^1)</h4> <ol><li>只比较同一层级，不跨级比较</li> <li>tag 不相同，则直接删掉重建，不再深度比较</li> <li>tag 和 key，两者都相同，则认为是相同节点，不再深度比较</li></ol> <h3 id="_25-描述下vue自定义指令"><a href="#_25-描述下vue自定义指令" class="header-anchor">#</a> 25. 描述下Vue自定义指令</h3> <p>在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。 一般需要对DOM元素进行底层操作时使用，尽量只用来操作 DOM展示，不修改内部的值。当使用自定义指令直接修改 value 值时绑定v-model的值也不会同步更新；如必须修改可以在自定义指令中使用keydown事件，在vue组件中使用 change事件，回调中修改vue数据;</p> <p><strong>（1）自定义指令基本内容</strong></p> <ul><li><p>全局定义：<code>Vue.directive(&quot;focus&quot;,{})</code></p></li> <li><p>局部定义：<code>directives:{focus:{}}</code></p></li> <li><p>钩子函数：指令定义对象提供钩子函数</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>o bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。
o inSerted：被绑定元素插入父节点时调用（仅保证父节点存在，但不一定已被插入文档中）。
o update：所在组件的VNode更新时调用，但是可能发生在其子VNode更新之前调用。指令的值可能发生了改变，也可能没有。但是可以通过比较更新前后的值来忽略不必要的模板更新。
o ComponentUpdate：指令所在组件的 VNode及其子VNode全部更新后调用。
o unbind：只调用一次，指令与元素解绑时调用。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li> <li><p>钩子函数参数</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>o el：绑定元素
o bing： 指令核心对象，描述指令全部信息属性
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li></ul> <p>o name o value o oldValue o expression o arg o modifers o vnode  虚拟节点 o oldVnode：上一个虚拟节点（更新钩子函数中才有用）</p> <p><strong>（2）使用场景</strong></p> <ul><li>普通DOM元素进行底层操作的时候，可以使用自定义指令</li> <li>自定义指令是用来操作DOM的。尽管Vue推崇数据驱动视图的理念，但并非所有情况都适合数据驱动。自定义指令就是一种有效的补充和扩展，不仅可用于定义任何的DOM操作，并且是可复用的。</li></ul> <p><strong>（3）使用案例</strong></p> <p>初级应用：</p> <ul><li>鼠标聚焦</li> <li>下拉菜单</li> <li>相对时间转换</li> <li>滚动动画</li></ul> <p>高级应用：</p> <ul><li>自定义指令实现图片懒加载</li> <li>自定义指令集成第三方插件</li></ul> <h3 id="_26-子组件可以直接改变父组件的数据吗"><a href="#_26-子组件可以直接改变父组件的数据吗" class="header-anchor">#</a> 26. 子组件可以直接改变父组件的数据吗？</h3> <p>子组件不可以直接改变父组件的数据。这样做主要是为了维护父子组件的单向数据流。每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。如果这样做了，Vue 会在浏览器的控制台中发出警告。</p> <p>Vue提倡单向数据流，即父级 props 的更新会流向子组件，但是反过来则不行。这是为了防止意外的改变父组件状态，使得应用的数据流变得难以理解，导致数据流混乱。如果破坏了单向数据流，当应用复杂时，debug 的成本会非常高。</p> <p><strong>只能通过 <code>$emit</code> 派发一个自定义事件，父组件接收到后，由父组件修改。</strong></p> <h3 id="_27-vue是如何收集依赖的"><a href="#_27-vue是如何收集依赖的" class="header-anchor">#</a> 27. Vue是如何收集依赖的？</h3> <p>在初始化 Vue 的每个组件时，会对组件的 data 进行初始化，就会将由普通对象变成响应式对象，在这个过程中便会进行依赖收集的相关逻辑，如下所示∶</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">defieneReactive</span> <span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">const</span> dep <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token operator">...</span>
  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span>
    <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token function">reactiveGetter</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span><span class="token punctuation">{</span>
        dep<span class="token punctuation">.</span><span class="token function">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">...</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span> val
    <span class="token punctuation">}</span>
    <span class="token operator">...</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>以上只保留了关键代码，主要就是 <code>const dep = new Dep()</code>实例化一个 Dep 的实例，然后在 get 函数中通过 <code>dep.depend()</code> 进行依赖收集。 <strong>（1）Dep</strong> Dep是整个依赖收集的核心，其关键代码如下：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Dep</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> target<span class="token punctuation">;</span>
  subs<span class="token punctuation">;</span>

  <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>subs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">addSub</span> <span class="token punctuation">(</span><span class="token parameter">sub</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>sub<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token function">removeSub</span> <span class="token punctuation">(</span><span class="token parameter">sub</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>sub<span class="token punctuation">,</span> sub<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token function">depend</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span><span class="token punctuation">{</span>
      Dep<span class="token punctuation">.</span>target<span class="token punctuation">.</span><span class="token function">addDep</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token function">notify</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> subs <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>subds<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> subs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      subs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p>Dep 是一个 class ，其中有一个关 键的静态属性 static，它指向了一个全局唯一 Watcher，保证了同一时间全局只有一个 watcher 被计算，另一个属性 subs 则是一个 Watcher 的数组，所以 Dep 实际上就是对 Watcher 的管理，再看看 Watcher 的相关代码∶</p> <p><strong>（2）Watcher</strong></p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Watcher</span> <span class="token punctuation">{</span>
  getter<span class="token punctuation">;</span>
  <span class="token operator">...</span>
  <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token parameter">vm<span class="token punctuation">,</span> expression</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token operator">...</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>getter <span class="token operator">=</span> expression<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">get</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">pushTarget</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getter</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> vm<span class="token punctuation">)</span>
    <span class="token operator">...</span>
    <span class="token keyword">return</span> value
  <span class="token punctuation">}</span>
  <span class="token function">addDep</span> <span class="token punctuation">(</span><span class="token parameter">dep</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token operator">...</span>
    dep<span class="token punctuation">.</span><span class="token function">addSub</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token operator">...</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">pushTarget</span> <span class="token punctuation">(</span><span class="token parameter">_target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> _target
<span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>Watcher 是一个 class，它定义了一些方法，其中和依赖收集相关的主要有 get、addDep 等。</p> <p><strong>（3）过程</strong></p> <p>在实例化 Vue 时，依赖收集的相关过程如下∶ 初 始 化 状 态 initState ， 这 中 间 便 会 通 过 defineReactive 将数据变成响应式对象，其中的 getter 部分便是用来依赖收集的。 初始化最终会走 mount 过程，其中会实例化 Watcher ，进入 Watcher 中，便会执行 this.get() 方法，</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token function-variable function">updateComponent</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  vm<span class="token punctuation">.</span><span class="token function">_update</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span><span class="token function">_render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">new</span> <span class="token class-name">Watcher</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> updateComponent<span class="token punctuation">)</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>get 方 法 中 的 pushTarget 实际上就是把 Dep.target 赋值为当前的 watcher。</p> <p>this.getter.call（vm，vm），这里的 getter 会执行 vm._render() 方法，在这个过程中便会触发数据对象的 getter。那么每个对象值的 getter 都持有一个 dep，在触发 getter 的时候会调用 dep.depend() 方法，也就会执行 Dep.target.addDep(this)。刚才 Dep.target 已经被赋值为 watcher，于是便会执行 addDep 方法，然后走到 dep.addSub() 方法，便将当前的 watcher 订阅到这个数据持有的 dep 的 subs 中，这个目的是为后续数据变化时候能通知到哪些 subs 做准备。所以在 vm._render() 过程中，会触发所有数据的 getter，这样便已经完成了一个依赖收集的过程。</p> <h3 id="_28-说一下对-react-和-vue-的理解-它们的异同"><a href="#_28-说一下对-react-和-vue-的理解-它们的异同" class="header-anchor">#</a> 28. 说一下对 React 和 Vue 的理解，它们的异同</h3> <p><strong>（1）相似之处</strong></p> <ul><li>都将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库</li> <li>都有自己的构建工具，能让你得到一个根据最佳实践设置的项目模板。</li> <li>都使用了Virtual DOM（虚拟DOM）提高重绘性能</li> <li>都有props的概念，允许组件间的数据传递</li> <li>都鼓励组件化应用，将应用分拆成一个个功能明确的模块，提高复用性</li></ul> <p><strong>（2）不同之处</strong></p> <p><strong>1）数据流</strong></p> <p>Vue默认支持数据双向绑定，而React一直提倡单向数据流</p> <p><strong>2）虚拟DOM</strong></p> <p>Vue2.x开始引入&quot;Virtual DOM&quot;，消除了和React在这方面的差异，但是在具体的细节还是有各自的特点。</p> <ul><li>Vue宣称可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。</li> <li>对于React而言，每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过 PureComponent/shouldComponentUpdate这个生命周期方法来进行控制，但Vue将此视为默认的优化。</li></ul> <p><strong>3）组件化</strong></p> <p>React与Vue最大的不同是模板的编写。</p> <ul><li>Vue鼓励写近似常规HTML的模板。写起来很接近标准 HTML元素，只是多了一些属性。</li> <li>React推荐你所有的模板通用JavaScript的语法扩展——JSX书写。</li></ul> <p>具体来讲：React中render函数是支持闭包特性的，所以我们import的组件在render中可以直接调用。但是在Vue中，由于模板中使用的数据都必须挂在 this 上进行一次中转，所以我们 import 一个组件完了之后，还需要在 components 中再声明下。</p> <p><strong>4）监听数据变化的实现原理不同</strong></p> <ul><li>Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能</li> <li>React 默认是通过比较引用的方式进行的，如果不优化（PureComponent/shouldComponentUpdate）可能导致大量不必要的vDOM的重新渲染。这是因为 Vue 使用的是可变数据，而React更强调数据的不可变。</li></ul> <p><strong>5）高阶组件</strong></p> <p>react可以通过高阶组件（Higher Order Components-- HOC）来扩展，而vue需要通过mixins来扩展。</p> <p>原因高阶组件就是高阶函数，而React的组件本身就是纯粹的函数，所以高阶函数对React来说易如反掌。相反Vue.js使用HTML模板创建视图组件，这时模板无法有效的编译，因此Vue不采用HOC来实现。</p> <p><strong>6）构建工具</strong></p> <p>两者都有自己的构建工具</p> <ul><li>React ==&gt; Create React APP</li> <li>Vue ==&gt; vue-cli</li></ul> <p><strong>7）跨平台</strong></p> <ul><li>React ==&gt; React Native</li> <li>Vue ==&gt; Weex</li></ul> <h3 id="_29-vue的优点"><a href="#_29-vue的优点" class="header-anchor">#</a> 29. Vue的优点</h3> <ul><li>轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十 <code>kb</code> ；</li> <li>简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；</li> <li>双向数据绑定：保留了 <code>angular</code> 的特点，在数据操作方面更为简单；</li> <li>组件化：保留了 <code>react</code> 的优点，实现了 <code>html</code> 的封装和重用，在构建单页面应用方面有着独特的优势；</li> <li>视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；</li> <li>虚拟DOM：<code>dom</code> 操作是非常耗费性能的， 不再使用原生的 <code>dom</code> 操作节点，极大解放 <code>dom</code> 操作，但具体操作的还是 <code>dom</code> 不过是换了另一种方式；</li> <li>运行速度更快：相比较于 <code>react</code> 而言，同样是操作虚拟 <code>dom</code> ，就性能而言， <code>vue</code> 存在很大的优势。</li></ul> <h3 id="_30-assets和static的区别"><a href="#_30-assets和static的区别" class="header-anchor">#</a> 30. assets和static的区别</h3> <p><strong>相同点：</strong> <code>assets</code> 和 <code>static</code> 两个都是存放静态资源文件。项目中所需要的资源文件图片，字体图标，样式文件等都可以放在这两个文件下，这是相同点</p> <p><strong>不相同点：</strong><code>assets</code> 中存放的静态资源文件在项目打包时，也就是运行 <code>npm run build</code> 时会将 <code>assets</code> 中放置的静态资源文件进行打包上传，所谓打包简单点可以理解为压缩体积，代码格式化。而压缩后的静态资源文件最终也都会放置在 <code>static</code> 文件中跟着 <code>index.html</code> 一同上传至服务器。<code>static</code> 中放置的静态资源文件就不会要走打包压缩格式化等流程，而是直接进入打包好的目录，直接上传至服务器。因为避免了压缩直接进行上传，在打包时会提高一定的效率，但是 <code>static</code> 中的资源文件由于没有进行压缩等操作，所以文件的体积也就相对于 <code>assets</code> 中打包后的文件提交较大点。在服务器中就会占据更大的空间。</p> <p><strong>建议：</strong> 将项目中 <code>template</code>需要的样式文件js文件等都可以放置在 <code>assets</code> 中，走打包这一流程。减少体积。而项目中引入的第三方的资源文件如<code>iconfoont.css</code> 等文件可以放置在 <code>static</code> 中，因为这些引入的第三方文件已经经过处理，我们不再需要处理，直接上传。</p> <h3 id="_31-delete和vue-delete删除数组的区别"><a href="#_31-delete和vue-delete删除数组的区别" class="header-anchor">#</a> 31. delete和Vue.delete删除数组的区别</h3> <ul><li><code>delete</code> 只是被删除的元素变成了 <code>empty/undefined</code> 其他的元素的键值还是不变。</li> <li><code>Vue.delete</code> 直接删除了数组 改变了数组的键值。</li></ul> <h3 id="_32-vue如何监听对象或者数组某个属性的变化"><a href="#_32-vue如何监听对象或者数组某个属性的变化" class="header-anchor">#</a> 32. vue如何监听对象或者数组某个属性的变化</h3> <p>当在项目中直接设置数组的某一项的值，或者直接设置对象的某个属性值，这个时候，你会发现页面并没有更新。这是因为Object.defineProperty()限制，监听不到变化。 解决方式：</p> <ul><li>this.$set(你要改变的数组/对象，你要改变的位置/key，你要改成什么value)</li></ul> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">&quot;OBKoro1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 改变数组</span>
<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">,</span> <span class="token string">&quot;c&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;OBKoro1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 改变对象</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li>调用以下几个数组的方法</li></ul> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token function">splice</span><span class="token punctuation">(</span><span class="token punctuation">)</span>、 <span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">、pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">、shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">、unshift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">、sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">、reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>vue源码里缓存了array的原型链，然后重写了这几个方法，触发这几个方法的时候会observer数据，意思是使用这些方法不用我们再进行额外的操作，视图自动进行更新。 推荐使用splice方法会比较好自定义,因为splice可以在数组的任何位置进行删除/添加操作</p> <p>vm.<code>$set</code> 的实现原理是：</p> <ul><li>如果目标是数组，直接使用数组的 splice 方法触发相应式；</li> <li>如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用 defineReactive 方法进行响应式处理（ defineReactive 方法就是 Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法）</li></ul> <h3 id="_33-什么是-mixin"><a href="#_33-什么是-mixin" class="header-anchor">#</a> 33. 什么是 mixin ？</h3> <ul><li>Mixin 使我们能够为 Vue 组件编写可插拔和可重用的功能。</li> <li>如果你希望在多个组件之间重用一组组件选项，例如生命周期 hook、 方法等，则可以将其编写为 mixin，并在组件中简单的引用它。</li> <li>然后将 mixin 的内容合并到组件中。如果你要在 mixin 中定义生命周期 hook，那么它在执行时将优化于组件自已的 hook。</li></ul> <h3 id="_34-vue模版编译原理"><a href="#_34-vue模版编译原理" class="header-anchor">#</a> 34. Vue模版编译原理</h3> <p>vue中的模板template无法被浏览器解析并渲染，因为这不属于浏览器的标准，不是正确的HTML语法，所有需要将template转化成一个JavaScript函数，这样浏览器就可以执行这一个函数并渲染出对应的HTML元素，就可以让视图跑起来了，这一个转化的过程，就成为模板编译。模板编译又分三个阶段，解析parse，优化optimize，生成generate，最终生成可执行函数render。</p> <ul><li><strong>解析阶段</strong>：使用大量的正则表达式对template字符串进行解析，将标签、指令、属性等转化为抽象语法树AST。</li> <li><strong>优化阶段</strong>：遍历AST，找到其中的一些静态节点并进行标记，方便在页面重渲染的时候进行diff比较时，直接跳过这一些静态节点，优化runtime的性能。</li> <li><strong>生成阶段</strong>：将最终的AST转化为render函数字符串。</li></ul> <h3 id="_35-对ssr的理解"><a href="#_35-对ssr的理解" class="header-anchor">#</a> 35. 对SSR的理解</h3> <p>SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端</p> <p>SSR的优势：</p> <ul><li>更好的SEO</li> <li>首屏加载速度更快</li></ul> <p>SSR的缺点：</p> <ul><li>开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子</li> <li>当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境</li> <li>更多的服务端负载</li></ul> <h3 id="_36-vue的性能优化有哪些"><a href="#_36-vue的性能优化有哪些" class="header-anchor">#</a> 36. Vue的性能优化有哪些</h3> <p><strong>（1）编码阶段</strong></p> <ul><li>尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher</li> <li>v-if和v-for不能连用</li> <li>如果需要使用v-for给每项元素绑定事件时使用事件代理</li> <li>SPA 页面采用keep-alive缓存组件</li> <li>在更多的情况下，使用v-if替代v-show</li> <li>key保证唯一</li> <li>使用路由懒加载、异步组件</li> <li>防抖、节流</li> <li>第三方模块按需导入</li> <li>长列表滚动到可视区域动态加载</li> <li>图片懒加载</li></ul> <p><strong>（2）SEO优化</strong></p> <ul><li>预渲染</li> <li>服务端渲染SSR</li></ul> <p><strong>（3）打包优化</strong></p> <ul><li>压缩代码</li> <li>Tree Shaking/Scope Hoisting</li> <li>使用cdn加载第三方模块</li> <li>多线程打包happypack</li> <li>splitChunks抽离公共文件</li> <li>sourceMap优化</li></ul> <p><strong>（4）用户体验</strong></p> <ul><li>骨架屏</li> <li>PWA</li> <li>还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启gzip压缩等。</li></ul> <h3 id="_37-对-spa-单页面的理解-它的优缺点分别是什么"><a href="#_37-对-spa-单页面的理解-它的优缺点分别是什么" class="header-anchor">#</a> 37. 对 SPA 单页面的理解，它的优缺点分别是什么？</h3> <p>SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。</p> <p>优点：</p> <ul><li>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；</li> <li>基于上面一点，SPA 相对对服务器压力小；</li> <li>前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；</li></ul> <p>缺点：</p> <ul><li>初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；</li> <li>前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；</li> <li>SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。</li></ul> <h3 id="_38-template和jsx的有什么分别"><a href="#_38-template和jsx的有什么分别" class="header-anchor">#</a> 38. template和jsx的有什么分别？</h3> <p>对于 runtime 来说，只需要保证组件存在 render 函数即可，而我们有了预编译之后，我们只需要保证构建过程中生成 render 函数就可以。在 webpack 中，我们使用<code>vue-loader</code>编译.vue文件，内部依赖的<code>vue-template-compiler</code>模块，在 webpack 构建过程中，将template预编译成 render 函数。与 react 类似，在添加了jsx的语法糖解析器<code>babel-plugin-transform-vue-jsx</code>之后，就可以直接手写render函数。</p> <p>所以，template和jsx的都是render的一种表现形式，不同的是：JSX相对于template而言，具有更高的灵活性，在复杂的组件中，更具有优势，而 template 虽然显得有些呆滞。但是 template 在代码结构上更符合视图与逻辑分离的习惯，更简单、更直观、更好维</p> <h3 id="_39-vue初始化页面闪动问题"><a href="#_39-vue初始化页面闪动问题" class="header-anchor">#</a> 39. vue初始化页面闪动问题</h3> <p>使用vue开发时，在vue初始化之前，由于div是不归vue管的，所以我们写的代码在还没有解析的情况下会容易出现花屏现象，看到类似于的字样，虽然一般情况下这个时间很短暂，但是我们还是有必要让解决这个问题的。</p> <p>首先：在css里加上以下代码：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token punctuation">[</span>v<span class="token operator">-</span>cloak<span class="token punctuation">]</span> <span class="token punctuation">{</span>
    display<span class="token operator">:</span> none<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>如果没有彻底解决问题，则在根元素加上style=&quot;display: none;&quot; :style=&quot;{display: 'block'}&quot;</p> <h2 id="_0-那你能讲一讲mvvm吗"><a href="#_0-那你能讲一讲mvvm吗" class="header-anchor">#</a> 0.那你能讲一讲MVVM吗？</h2> <p>MVVM是<code>Model-View-ViewModel</code>缩写，也就是把<code>MVC</code>中的<code>Controller</code>演变成<code>ViewModel</code>。Model层代表数据模型，View代表UI组件，ViewModel是View和Model层的桥梁，数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据。</p> <h2 id="_1-简单说一下vue2-x响应式数据原理"><a href="#_1-简单说一下vue2-x响应式数据原理" class="header-anchor">#</a> 1.简单说一下Vue2.x响应式数据原理</h2> <p>Vue在初始化数据时，会使用<code>Object.defineProperty</code>重新定义data中的所有属性，当页面使用对应属性时，首先会进行依赖收集(收集当前组件的<code>watcher</code>)如果属性发生变化会通知相关依赖进行更新操作(<code>发布订阅</code>)。</p> <h2 id="_2-那你知道vue3-x响应式数据原理吗"><a href="#_2-那你知道vue3-x响应式数据原理吗" class="header-anchor">#</a> 2.那你知道Vue3.x响应式数据原理吗？</h2> <p>(还好我有看，这个难不倒我)</p> <p>Vue3.x改用<code>Proxy</code>替代Object.defineProperty。因为Proxy可以直接监听对象和数组的变化，并且有多达13种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化。</p> <blockquote><p>❝</p> <p>Proxy只会代理对象的第一层，那么Vue3又是怎样处理这个问题的呢？</p> <p>❞</p></blockquote> <p>（很简单啊）</p> <p>判断当前Reflect.get的返回值是否为Object，如果是则再通过<code>reactive</code>方法做代理， 这样就实现了深度观测。</p> <blockquote><p>❝</p> <p>监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？</p> <p>❞</p></blockquote> <p>我们可以判断key是否为当前被代理对象target自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行trigger。</p> <p>面试官抬起了头。心里暗想</p> <p>(这小子还行，比上两个强，应该是多多少少看过Vue3的源码了)</p> <h2 id="_3-再说一下vue2-x中如何监测数组变化"><a href="#_3-再说一下vue2-x中如何监测数组变化" class="header-anchor">#</a> 3.再说一下vue2.x中如何监测数组变化</h2> <p>使用了函数劫持的方式，重写了数组的方法，Vue将data中的数组进行了原型链重写，指向了自己定义的数组原型方法。这样当调用数组api时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。</p> <p>（能问到这的面试官都比较注重深度，这些常规操作要记牢）</p> <p>（原型链的细节可以参考我的另一篇专栏）</p> <p><a href="https://juejin.im/post/6844903893520875527" target="_blank" rel="noopener noreferrer">一文带你彻底搞懂JavaScript原型链<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="_4-nexttick知道吗-实现原理是什么"><a href="#_4-nexttick知道吗-实现原理是什么" class="header-anchor">#</a> 4.nextTick知道吗，实现原理是什么？</h2> <p>在下次 DOM 更新循环结束之后执行延迟回调。nextTick主要使用了宏任务和微任务。根据执行环境分别尝试采用</p> <ul><li>Promise</li> <li>MutationObserver</li> <li>setImmediate</li> <li>如果以上都不行则采用setTimeout</li></ul> <p>定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。</p> <p>（关于宏任务和微任务以及事件循环可以参考我的另两篇专栏）</p> <p>(看到这你就会发现，其实问框架最终还是考验你的原生JavaScript功底)</p> <p><a href="https://juejin.im/post/6844903881663578119" target="_blank" rel="noopener noreferrer">浏览器中JavaScript的事件循环<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://juejin.im/post/6844904007270563848" target="_blank" rel="noopener noreferrer">Node.js事件循环<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="_5-说一下vue的生命周期"><a href="#_5-说一下vue的生命周期" class="header-anchor">#</a> 5.说一下Vue的生命周期</h2> <p><code>beforeCreate</code>是new Vue()之后触发的第一个钩子，在当前阶段data、methods、computed以及watch上的数据和方法都不能被访问。</p> <p><code>created</code>在实例创建完成后发生，当前阶段已经完成了数据观测，也就是可以使用数据，更改数据，在这里更改数据不会触发updated函数。可以做一些初始数据的获取，在当前阶段无法与Dom进行交互，如果非要想，可以通过vm.$nextTick来访问Dom。</p> <p><code>beforeMount</code>发生在挂载之前，在这之前template模板已导入渲染函数编译。而当前阶段虚拟Dom已经创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发updated。</p> <p><code>mounted</code>在挂载完成后发生，在当前阶段，真实的Dom挂载完毕，数据完成双向绑定，可以访问到Dom节点，使用$refs属性对Dom进行操作。</p> <p><code>beforeUpdate</code>发生在更新之前，也就是响应式数据发生更新，虚拟dom重新渲染之前被触发，你可以在当前阶段进行更改数据，不会造成重渲染。</p> <p><code>updated</code>发生在更新完成之后，当前阶段组件Dom已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新。</p> <p><code>beforeDestroy</code>发生在实例销毁之前，在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器。</p> <p><code>destroyed</code>发生在实例销毁之后，这个时候只剩下了dom空壳。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。</p> <p>(关于Vue的生命周期详解感兴趣的也请移步我的另一篇专栏)</p> <p><a href="https://juejin.im/post/6844903879100858382" target="_blank" rel="noopener noreferrer">从源码解读Vue生命周期，让面试官对你刮目相看<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="_6-你的接口请求一般放在哪个生命周期中"><a href="#_6-你的接口请求一般放在哪个生命周期中" class="header-anchor">#</a> 6.你的接口请求一般放在哪个生命周期中？</h2> <p>接口请求一般放在<code>mounted</code>中，但需要注意的是服务端渲染时不支持mounted，需要放到<code>created</code>中。</p> <h2 id="_7-再说一下computed和watch"><a href="#_7-再说一下computed和watch" class="header-anchor">#</a> 7.再说一下Computed和Watch</h2> <p><code>Computed</code>本质是一个具备缓存的watcher，依赖的属性发生变化就会更新视图。 适用于计算比较消耗性能的计算场景。当表达式过于复杂时，在模板中放入过多逻辑会让模板难以维护，可以将复杂的逻辑放入计算属性中处理。</p> <p><code>Watch</code>没有缓存性，更多的是观察的作用，可以监听某些数据执行回调。当我们需要深度监听对象中的属性时，可以打开<code>deep：true</code>选项，这样便会对对象中的每一项进行监听。这样会带来性能问题，优化的话可以使用<code>字符串形式</code>监听，如果没有写到组件中，不要忘记使用<code>unWatch手动注销</code>哦。</p> <h2 id="_8-说一下v-if和v-show的区别"><a href="#_8-说一下v-if和v-show的区别" class="header-anchor">#</a> 8.说一下v-if和v-show的区别</h2> <p>当条件不成立时，<code>v-if</code>不会渲染DOM元素，<code>v-show</code>操作的是样式(display)，切换当前DOM的显示和隐藏。</p> <h2 id="_9-组件中的data为什么是一个函数"><a href="#_9-组件中的data为什么是一个函数" class="header-anchor">#</a> 9.组件中的data为什么是一个函数？</h2> <p>一个组件被复用多次的话，也就会创建多个实例。本质上，<code>这些实例用的都是同一个构造函数</code>。如果data是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间data不冲突，data必须是一个函数。</p> <h2 id="_10-说一下v-model的原理"><a href="#_10-说一下v-model的原理" class="header-anchor">#</a> 10.说一下v-model的原理</h2> <p><code>v-model</code>本质就是一个语法糖，可以看成是<code>value + input</code>方法的语法糖。 可以通过model属性的<code>prop</code>和<code>event</code>属性来进行自定义。原生的v-model，会根据标签的不同生成不同的事件和属性。</p> <h2 id="_11-vue事件绑定原理说一下"><a href="#_11-vue事件绑定原理说一下" class="header-anchor">#</a> 11.Vue事件绑定原理说一下</h2> <p>原生事件绑定是通过<code>addEventListener</code>绑定给真实元素的，组件事件绑定是通过Vue自定义的<code>$on</code>实现的。</p> <blockquote><p>❝</p> <p>面试官：(这小子基础还可以，接下来我得上上难度了)</p> <p>❞</p></blockquote> <h2 id="_12-vue模版编译原理知道吗-能简单说一下吗"><a href="#_12-vue模版编译原理知道吗-能简单说一下吗" class="header-anchor">#</a> 12.Vue模版编译原理知道吗，能简单说一下吗？</h2> <p>简单说，Vue的编译过程就是将<code>template</code>转化为<code>render</code>函数的过程。会经历以下阶段：</p> <ul><li>生成AST树</li> <li>优化</li> <li>codegen</li></ul> <p>首先解析模版，生成<code>AST语法树</code>(一种用JavaScript对象的形式来描述整个模板)。 使用大量的正则表达式对模板进行解析，遇到标签、文本的时候都会执行对应的钩子进行相关处理。</p> <p>Vue的数据是响应式的，但其实模板中并不是所有的数据都是响应式的。有一些数据首次渲染后就不会再变化，对应的DOM也不会变化。那么优化过程就是深度遍历AST树，按照相关条件对树节点进行标记。这些被标记的节点(静态节点)我们就可以<code>跳过对它们的比对</code>，对运行时的模板起到很大的优化作用。</p> <p>编译的最后一步是<code>将优化后的AST树转换为可执行的代码</code>。</p> <blockquote><p>❝</p> <p>面试官：(精神小伙啊，有点东西，难度提升，不信难不倒你)</p> <p>❞</p></blockquote> <h2 id="_13-vue2-x和vue3-x渲染器的diff算法分别说一下"><a href="#_13-vue2-x和vue3-x渲染器的diff算法分别说一下" class="header-anchor">#</a> 13.Vue2.x和Vue3.x渲染器的diff算法分别说一下</h2> <p>简单来说，diff算法有以下过程</p> <ul><li>同级比较，再比较子节点</li> <li>先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)</li> <li>比较都有子节点的情况(核心diff)</li> <li>递归比较子节点</li></ul> <p>正常Diff两个树的时间复杂度是<code>O(n^3)</code>，但实际情况下我们很少会进行<code>跨层级的移动DOM</code>，所以Vue将Diff进行了优化，从<code>O(n^3) -&gt; O(n)</code>，只有当新旧children都为多个子节点时才需要用核心的Diff算法进行同层级比较。</p> <p>Vue2的核心Diff算法采用了<code>双端比较</code>的算法，同时从新旧children的两端开始进行比较，借助key值找到可复用的节点，再进行相关操作。相比React的Diff算法，同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅。</p> <p>Vue3.x借鉴了 <a href="https://github.com/localvoid/ivi" target="_blank" rel="noopener noreferrer">ivi<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>算法和 <a href="https://github.com/infernojs/inferno" target="_blank" rel="noopener noreferrer">inferno<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>算法</p> <p>在创建VNode时就确定其类型，以及在<code>mount/patch</code>的过程中采用<code>位运算</code>来判断一个VNode的类型，在这个基础之上再配合核心的Diff算法，使得性能上较Vue2.x有了提升。(实际的实现可以结合Vue3.x源码看。)</p> <p>该算法中还运用了<code>动态规划</code>的思想求解最长递归子序列。</p> <p>(看到这你还会发现，框架内无处不蕴藏着数据结构和算法的魅力)</p> <blockquote><p>❝</p> <p>面试官：(可以可以，看来是个苗子，不过自我介绍属实有些无聊，下一题)</p> <p>❞</p></blockquote> <p>(基操，勿6)</p> <h2 id="_14-再说一下虚拟dom以及key属性的作用"><a href="#_14-再说一下虚拟dom以及key属性的作用" class="header-anchor">#</a> 14.再说一下虚拟Dom以及key属性的作用</h2> <p>由于在浏览器中操作DOM是很昂贵的。频繁的操作DOM，会产生一定的性能问题。这就是虚拟Dom的<code>产生原因</code>。</p> <p>Vue2的Virtual DOM借鉴了开源库<code>snabbdom</code>的实现。</p> <p><code>Virtual DOM本质就是用一个原生的JS对象去描述一个DOM节点。是对真实DOM的一层抽象。</code>(也就是源码中的VNode类，它定义在src/core/vdom/vnode.js中。)</p> <p>VirtualDOM映射到真实DOM要经历VNode的create、diff、patch等阶段。</p> <p><strong>「key的作用是尽可能的复用 DOM 元素。」</strong></p> <p>新旧 children 中的节点只有顺序是不同的时候，最佳的操作应该是通过移动元素的位置来达到更新的目的。</p> <p>需要在新旧 children 的节点中保存映射关系，以便能够在旧 children 的节点中找到可复用的节点。key也就是children中节点的唯一标识。</p> <h2 id="_15-keep-alive了解吗"><a href="#_15-keep-alive了解吗" class="header-anchor">#</a> 15.keep-alive了解吗</h2> <p><code>keep-alive</code>可以实现组件缓存，当组件切换时不会对当前组件进行卸载。</p> <p>常用的两个属性<code>include/exclude</code>，允许组件有条件的进行缓存。</p> <p>两个生命周期<code>activated/deactivated</code>，用来得知当前组件是否处于活跃状态。</p> <p>keep-alive的中还运用了<code>LRU(Least Recently Used)</code>算法。</p> <p>（又是数据结构与算法，原来算法在前端也有这么多的应用）</p> <h2 id="_16-vue中组件生命周期调用顺序说一下"><a href="#_16-vue中组件生命周期调用顺序说一下" class="header-anchor">#</a> 16.Vue中组件生命周期调用顺序说一下</h2> <p>组件的调用顺序都是<code>先父后子</code>,渲染完成的顺序是<code>先子后父</code>。</p> <p>组件的销毁操作是<code>先父后子</code>，销毁完成的顺序是<code>先子后父</code>。</p> <h3 id="加载渲染过程"><a href="#加载渲染过程" class="header-anchor">#</a> 加载渲染过程</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount- &gt;子mounted-&gt;父mounted
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="子组件更新过程"><a href="#子组件更新过程" class="header-anchor">#</a> 子组件更新过程</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="父组件更新过程"><a href="#父组件更新过程" class="header-anchor">#</a> 父组件更新过程</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>父 beforeUpdate -&gt; 父 updated
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="销毁过程"><a href="#销毁过程" class="header-anchor">#</a> 销毁过程</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_17-vue2-x组件通信有哪些方式"><a href="#_17-vue2-x组件通信有哪些方式" class="header-anchor">#</a> 17.Vue2.x组件通信有哪些方式？</h2> <ul><li><p>父子组件通信</p> <p>父-&gt;子<code>props</code>，子-&gt;父 <code>$on、$emit</code></p> <p>获取父子组件实例 <code>$parent、$children</code></p> <p><code>Ref</code> 获取实例的方式调用组件的属性或者方法</p> <p><code>Provide、inject</code> 官方不推荐使用，但是写组件库时很常用</p></li> <li><p>兄弟组件通信</p> <p><code>Event Bus</code> 实现跨组件通信 <code>Vue.prototype.$bus = new Vue</code></p> <p><code>Vuex</code></p></li> <li><p>跨级组件通信</p> <p><code>Vuex</code></p> <p><code>$attrs、$listeners</code></p> <p><code>Provide、inject</code></p></li></ul> <h2 id="_18-ssr了解吗"><a href="#_18-ssr了解吗" class="header-anchor">#</a> 18.SSR了解吗？</h2> <p>SSR也就是服务端渲染，<code>也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端</code>。</p> <p>SSR有着更好的SEO、并且首屏加载速度更快等优点。不过它也有一些缺点，比如我们的开发条件会受到限制，服务器端渲染只支持<code>beforeCreate</code>和<code>created</code>两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境。还有就是服务器会有更大的负载需求。</p> <h2 id="_19-你都做过哪些vue的性能优化"><a href="#_19-你都做过哪些vue的性能优化" class="header-anchor">#</a> 19.你都做过哪些Vue的性能优化？</h2> <h3 id="编码阶段"><a href="#编码阶段" class="header-anchor">#</a> 编码阶段</h3> <ul><li>尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher</li> <li>v-if和v-for不能连用</li> <li>如果需要使用v-for给每项元素绑定事件时使用事件代理</li> <li>SPA 页面采用keep-alive缓存组件</li> <li>在更多的情况下，使用v-if替代v-show</li> <li>key保证唯一</li> <li>使用路由懒加载、异步组件</li> <li>防抖、节流</li> <li>第三方模块按需导入</li> <li>长列表滚动到可视区域动态加载</li> <li>图片懒加载</li></ul> <h3 id="seo优化"><a href="#seo优化" class="header-anchor">#</a> SEO优化</h3> <ul><li>预渲染</li> <li>服务端渲染SSR</li></ul> <h3 id="打包优化"><a href="#打包优化" class="header-anchor">#</a> 打包优化</h3> <ul><li>压缩代码</li> <li>Tree Shaking/Scope Hoisting</li> <li>使用cdn加载第三方模块</li> <li>多线程打包happypack</li> <li>splitChunks抽离公共文件</li> <li>sourceMap优化</li></ul> <h3 id="用户体验"><a href="#用户体验" class="header-anchor">#</a> 用户体验</h3> <ul><li>骨架屏</li> <li>PWA</li></ul> <p>还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启gzip压缩等。</p> <p>(优化是个大工程，会涉及很多方面，这里申请另开一个专栏)</p> <h2 id="_20-hash路由和history路由实现原理说一下"><a href="#_20-hash路由和history路由实现原理说一下" class="header-anchor">#</a> 20.hash路由和history路由实现原理说一下</h2> <p><code>location.hash</code>的值实际就是URL中<code>#</code>后面的东西。</p> <p>history实际采用了HTML5中提供的API来实现，主要有<code>history.pushState()</code>和<code>history.replaceState()</code>。</p> <h2 id="生命周期"><a href="#生命周期" class="header-anchor">#</a> 生命周期</h2> <h3 id="_1-简单说一下vue的生命周期"><a href="#_1-简单说一下vue的生命周期" class="header-anchor">#</a> 1. 简单说一下Vue的生命周期</h3> <ol><li><strong>beforeCreate（创建前）</strong>：数据观测和初始化事件还未开始，此时 data 的响应式追踪、event/watcher 都还没有被设置，也就是说不能访问到data、computed、watch、methods上的方法和数据。</li> <li><strong>created（创建后）</strong> ：实例创建完成，实例上配置的 options 包括 data、computed、watch、methods 等都配置完成，但是此时渲染得节点还未挂载到 DOM，所以不能访问到 <code>$el</code> 属性。</li> <li><strong>beforeMount（挂载前）</strong>：在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置∶ 编译模板，把data里面的数据和模板生成html。此时还没有挂载html到页面上。</li> <li><strong>mounted（挂载后）</strong>：在el被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html 页面中。此过程中进行ajax交互。</li> <li><strong>beforeUpdate（更新前）</strong>：响应式数据更新时调用，此时虽然响应式数据更新了，但是对应的真实 DOM 还没有被渲染</li> <li><strong>updated（更新后）</strong> ：在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。此时 DOM 已经根据响应式数据的变化更新了。调用时，组件 DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。</li> <li><strong>beforeDestroy（销毁前）</strong>：实例销毁之前调用。这一步，实例仍然完全可用，<code>this</code> 仍能获取到实例。</li> <li><strong>destroyed（销毁后）</strong>：实例销毁后调用，调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务端渲染期间不被调用。</li></ol> <h3 id="_2-vue-的父组件和子组件生命周期钩子执行顺序是什么"><a href="#_2-vue-的父组件和子组件生命周期钩子执行顺序是什么" class="header-anchor">#</a> 2. Vue 的父组件和子组件生命周期钩子执行顺序是什么</h3> <ul><li>首次加载渲染过程： <code>父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted</code></li> <li>子组件更新过程： <code>父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated</code></li> <li>父组件更新过程： <code>父beforeUpdate-&gt;父updated</code></li> <li>销毁过程： <code>父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</code></li></ul> <h3 id="_3-vue-子组件和父组件执行顺序"><a href="#_3-vue-子组件和父组件执行顺序" class="header-anchor">#</a> 3. Vue 子组件和父组件执行顺序</h3> <p><strong>加载渲染过程：</strong></p> <p>1.父组件 beforeCreate</p> <p>2.父组件 created</p> <p>3.父组件 beforeMount</p> <p>4.子组件 beforeCreate</p> <p>5.子组件 created</p> <p>6.子组件 beforeMount</p> <p>7.子组件 mounted</p> <p>8.父组件 mounted</p> <p><strong>更新过程：</strong></p> <p>1.父组件 beforeUpdate</p> <p>2.子组件 beforeUpdate</p> <p>3.子组件 updated</p> <p>4.父组件 updated</p> <p><strong>销毁过程：</strong></p> <p>1.父组件 beforeDestroy</p> <p>2.子组件 beforeDestroy</p> <p>3.子组件 destroyed</p> <p>4.父组件 destoryed</p> <h3 id="_4-created和mounted的区别"><a href="#_4-created和mounted的区别" class="header-anchor">#</a> 4. created和mounted的区别</h3> <ul><li>created:在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。</li> <li>mounted:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。</li></ul> <h3 id="_5-接口请求一般放在哪个生命周期中"><a href="#_5-接口请求一般放在哪个生命周期中" class="header-anchor">#</a> 5. 接口请求一般放在哪个生命周期中？</h3> <ul><li>可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。</li> <li>但是推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：
<ul><li>能更快获取到服务端数据，减少页面loading 时间；</li> <li>ssr不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；</li></ul></li></ul> <h2 id="组件通信"><a href="#组件通信" class="header-anchor">#</a> 组件通信</h2> <p>组件通信的方式如下：</p> <h3 id="_1-props-emit"><a href="#_1-props-emit" class="header-anchor">#</a> （1） props  /  $emit</h3> <p>父组件通过<code>props</code>向子组件传递数据，子组件通过<code>$emit</code>和父组件通信</p> <h5 id="_1-父组件向子组件传值"><a href="#_1-父组件向子组件传值" class="header-anchor">#</a> 1. 父组件向子组件传值</h5> <ul><li><code>props</code>只能是父组件向子组件进行传值，<code>props</code>使得父子组件之间形成了一个单向下行绑定。子组件的数据会随着父组件不断更新。</li> <li><code>props</code> 可以显示定义一个或一个以上的数据，对于接收的数据，可以是各种数据类型，同样也可以传递一个函数。</li> <li><code>props</code>属性名规则：若在<code>props</code>中使用驼峰形式，模板中需要使用短横线的形式</li></ul> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 父组件</span>
<span class="token operator">&lt;</span>template<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">&quot;father&quot;</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>son <span class="token operator">:</span>msg<span class="token operator">=</span><span class="token string">&quot;msgData&quot;</span> <span class="token operator">:</span>fn<span class="token operator">=</span><span class="token string">&quot;myFunction&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>son<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">&gt;</span>

<span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
<span class="token keyword">import</span> son <span class="token keyword">from</span> <span class="token string">&quot;./son.vue&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> father<span class="token punctuation">,</span>
    <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        msgData<span class="token operator">:</span> <span class="token string">&quot;父组件数据&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    methods<span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;vue&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    components<span class="token operator">:</span> <span class="token punctuation">{</span>
        son
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>

<span class="token comment">// 子组件</span>
<span class="token operator">&lt;</span>template<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">&quot;son&quot;</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">{</span>msg<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>button @click<span class="token operator">=</span><span class="token string">&quot;fn&quot;</span><span class="token operator">&gt;</span>按钮<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token string">&quot;son&quot;</span><span class="token punctuation">,</span>
    props<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&quot;msg&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;fn&quot;</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br></div></div><h5 id="_2-子组件向父组件传值"><a href="#_2-子组件向父组件传值" class="header-anchor">#</a> 2. 子组件向父组件传值</h5> <ul><li><code>$emit</code>绑定一个自定义事件，当这个事件被执行的时就会将参数传递给父组件，而父组件通过<code>v-on</code>监听并接收参数。</li></ul> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 父组件</span>
<span class="token operator">&lt;</span>template<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">&quot;section&quot;</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>com<span class="token operator">-</span>article <span class="token operator">:</span>articles<span class="token operator">=</span><span class="token string">&quot;articleList&quot;</span> @onEmitIndex<span class="token operator">=</span><span class="token string">&quot;onEmitIndex&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>com<span class="token operator">-</span>article<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">{</span>currentIndex<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">&gt;</span>

<span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
<span class="token keyword">import</span> comArticle <span class="token keyword">from</span> <span class="token string">'./test/article.vue'</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">'comArticle'</span><span class="token punctuation">,</span>
  components<span class="token operator">:</span> <span class="token punctuation">{</span> comArticle <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      currentIndex<span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>
      articleList<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'红楼梦'</span><span class="token punctuation">,</span> <span class="token string">'西游记'</span><span class="token punctuation">,</span> <span class="token string">'三国演义'</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  methods<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">onEmitIndex</span><span class="token punctuation">(</span><span class="token parameter">idx</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>currentIndex <span class="token operator">=</span> idx
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>

<span class="token comment">//子组件</span>
<span class="token operator">&lt;</span>template<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>div v<span class="token operator">-</span><span class="token keyword">for</span><span class="token operator">=</span><span class="token string">&quot;(item, index) in articles&quot;</span> <span class="token operator">:</span>key<span class="token operator">=</span><span class="token string">&quot;index&quot;</span> @click<span class="token operator">=</span><span class="token string">&quot;emitIndex(index)&quot;</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">{</span>item<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">&gt;</span>

<span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  props<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'articles'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  methods<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">emitIndex</span><span class="token punctuation">(</span><span class="token parameter">index</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'onEmitIndex'</span><span class="token punctuation">,</span> index<span class="token punctuation">)</span> <span class="token comment">// 触发父组件的方法，并传递参数index</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br></div></div><h3 id="_2-eventbus事件总线-emit-on"><a href="#_2-eventbus事件总线-emit-on" class="header-anchor">#</a> （2）eventBus事件总线（$emit / $on）</h3> <p><code>eventBus</code>事件总线适用于<strong>父子组件</strong>、<strong>非父子组件</strong>等之间的通信，使用步骤如下：</p> <p><strong>（1）创建事件中心管理组件之间的通信</strong></p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// event-bus.js</span>

<span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> EventBus <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>（2）发送事件</strong> 假设我们有两个兄弟组件<code>firstCom</code>和<code>secondCom</code>：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token operator">&lt;</span>template<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>first<span class="token operator">-</span>com<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>first<span class="token operator">-</span>com<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>second<span class="token operator">-</span>com<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>second<span class="token operator">-</span>com<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">&gt;</span>

<span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
<span class="token keyword">import</span> firstCom <span class="token keyword">from</span> <span class="token string">'./firstCom.vue'</span>
<span class="token keyword">import</span> secondCom <span class="token keyword">from</span> <span class="token string">'./secondCom.vue'</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  components<span class="token operator">:</span> <span class="token punctuation">{</span> firstCom<span class="token punctuation">,</span> secondCom <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>在<code>firstCom</code>组件中发送事件：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token operator">&lt;</span>template<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>button @click<span class="token operator">=</span><span class="token string">&quot;add&quot;</span><span class="token operator">&gt;</span>加法<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>    
  <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">&gt;</span>

<span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span>EventBus<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./event-bus.js'</span> <span class="token comment">// 引入事件中心</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span><span class="token punctuation">{</span>
      num<span class="token operator">:</span><span class="token number">0</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  methods<span class="token operator">:</span><span class="token punctuation">{</span>
    <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      EventBus<span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'addition'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
        num<span class="token operator">:</span><span class="token keyword">this</span><span class="token punctuation">.</span>num<span class="token operator">++</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p><strong>（3）接收事件</strong></p> <p>在<code>secondCom</code>组件中发送事件：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token operator">&lt;</span>template<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>求和<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">&gt;</span>

<span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> EventBus <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./event-bus.js'</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      count<span class="token operator">:</span> <span class="token number">0</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    EventBus<span class="token punctuation">.</span><span class="token function">$on</span><span class="token punctuation">(</span><span class="token string">'addition'</span><span class="token punctuation">,</span> <span class="token parameter">param</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">+</span> param<span class="token punctuation">.</span>num<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>在上述代码中，这就相当于将<code>num</code>值存贮在了事件总线中，在其他组件中可以直接访问。事件总线就相当于一个桥梁，不用组件通过它来通信。</p> <p>虽然看起来比较简单，但是这种方法也有不变之处，如果项目过大，使用这种方式进行通信，后期维护起来会很困难。</p> <h3 id="_3-依赖注入-project-inject"><a href="#_3-依赖注入-project-inject" class="header-anchor">#</a> （3）依赖注入（project / inject）</h3> <p>这种方式就是Vue中的<strong>依赖注入</strong>，这应该算是Vue高阶的一个知识点吧，正好最近用到了这个依赖注入，那么就来写一下。</p> <p>该方法用于<strong>父子组件之间的通信</strong>。当然这里所说的父子不一定是真正的父子，也可以是祖孙组件，在层数很深的情况下，我们可以使用这种方法来进行传值。就不用一层一层的传递了。</p> <p><code>project / inject</code>是Vue提供的两个钩子，和<code>data</code>、<code>methods</code>是同级的。并且<code>project</code>的书写形式和<code>data</code>一样。</p> <ul><li><code>project</code> 钩子用来发送数据或方法</li> <li><code>inject</code>钩子用来接收数据或方法</li></ul> <p>在父组件中：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token function">provide</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">return</span> <span class="token punctuation">{</span>
    num<span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>num
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>在子组件中：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code>inject<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'num'</span><span class="token punctuation">]</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>我们还可以这样写，这样写就可以访问父组件中的所有属性：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token function">provide</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">return</span> <span class="token punctuation">{</span>
    app<span class="token operator">:</span> <span class="token keyword">this</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">return</span> <span class="token punctuation">{</span>
    num<span class="token operator">:</span> <span class="token number">1</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

inject<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'app'</span><span class="token punctuation">]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>app<span class="token punctuation">.</span>num<span class="token punctuation">)</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p><strong>注意：</strong> 依赖注入所提供的属性是<strong>非响应式</strong>的。</p> <h3 id="_3-ref-refs"><a href="#_3-ref-refs" class="header-anchor">#</a> （3）ref / refs</h3> <p>最近也用到这个方式来进行组件之间的通信，这种方式也是实现<strong>父子组件</strong>之间的通信。下面就来看一下。</p> <p><code>ref</code>： 这个属性用在子组件上，它的引用就指向了子组件的实例。可以通过实例来访问组件的数据和方法。</p> <p>在子组件中：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">data</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      name<span class="token operator">:</span> <span class="token string">'JavaScript'</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  methods<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">sayHello</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>在父组件中：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token operator">&lt;</span>template<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>child ref<span class="token operator">=</span><span class="token string">&quot;child&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>component<span class="token operator">-</span>a<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
  <span class="token keyword">import</span> child <span class="token keyword">from</span> <span class="token string">'./child.vue'</span>
  <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
    components<span class="token operator">:</span> <span class="token punctuation">{</span> child <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">mounted</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>child<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// JavaScript</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>child<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// hello</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h3 id="_4-parent-children"><a href="#_4-parent-children" class="header-anchor">#</a> （4）$parent / $children</h3> <ul><li>使用<code>$parent</code>可以让组件访问父组件的实例（访问的是上一级父组件的属性和方法）</li> <li>使用<code>$children</code>可以让组件访问子组件的实例，但是，<code>$children</code>并不能保证顺序，并且访问的数据也不是响应式的。</li></ul> <p>在子组件中：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token operator">&lt;</span>template<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>span<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">{</span>message<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>获取父组件的值为<span class="token operator">:</span>  <span class="token punctuation">{</span><span class="token punctuation">{</span>parentVal<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">&gt;</span>

<span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      message<span class="token operator">:</span> <span class="token string">'Vue'</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  computed<span class="token operator">:</span><span class="token punctuation">{</span>
    <span class="token function">parentVal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$parent<span class="token punctuation">.</span>msg<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>在父组件中：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 父组件中</span>
<span class="token operator">&lt;</span>template<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">&quot;hello_world&quot;</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">{</span>msg<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>child<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>child<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>button @click<span class="token operator">=</span><span class="token string">&quot;change&quot;</span><span class="token operator">&gt;</span>点击改变子组件值<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">&gt;</span>

<span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
<span class="token keyword">import</span> child <span class="token keyword">from</span> <span class="token string">'./child.vue'</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  components<span class="token operator">:</span> <span class="token punctuation">{</span> child <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      msg<span class="token operator">:</span> <span class="token string">'Welcome'</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  methods<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">change</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 获取到子组件</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>$children<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>message <span class="token operator">=</span> <span class="token string">'JavaScript'</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p>在上面的代码中，子组件获取到了父组件的<code>parentVal</code>值，父组件改变了子组件中<code>message</code>的值。</p> <p><strong>需要注意：</strong></p> <ul><li>通过<code>$parent</code>访问到的是上一级父组件的实例，可以使用<code>$root</code>来访问根组件的实例</li> <li>在组件中使用<code>$children</code>拿到的是所有的子组件的实例，它是一个数组，并且是无序的</li> <li>在根组件<code>#app</code>上拿<code>$parent</code>得到的是<code>new Vue()</code>的实例，在这实例上再拿<code>$parent</code>得到的是<code>undefined</code>，而在最底层的子组件拿<code>$children</code>是个空数组</li> <li><code>$children</code> 的值是<strong>数组</strong>，而<code>$parent</code>是个<strong>对象</strong></li></ul> <h3 id="_5-attrs-listeners"><a href="#_5-attrs-listeners" class="header-anchor">#</a> （5）$attrs / $listeners</h3> <p>我们考虑一种场景，如果A是B组件的父组件，B是C组件的父组件。如果我们想要组件A给组件C传递数据，这种隔代的数据，该使用哪种方式呢？</p> <p>如果是用<code>props/$emit</code>来一级一级的传递，确实可以完成，但是比较复杂；如果使用事件总线，在多人开发或者项目较大的时候，维护起来很麻烦；如果使用Vuex，的确也可以，但是如果仅仅是传递数据，那可能就有点浪费了。</p> <p>针对上述情况，Vue引入了<code>$attrs / $listeners</code>，实现组件之间的跨代通信。</p> <p>先来看一下<code>inheritAttrs</code>，它的默认值true，继承所有的父组件属性除<code>props</code>之外的所有属性；<code>inheritAttrs：false</code> 只继承class属性 。</p> <ul><li><code>$attrs</code>：继承所有的父组件属性（除了prop传递的属性、class 和 style ），一般用在子组件的子元素上</li> <li><code>$listeners</code>：该属性是一个对象，里面包含了作用在这个组件上的所有监听器，可以配合 <code>v-on=&quot;$listeners&quot;</code> 将所有的事件监听器指向这个组件的某个特定的子元素。（相当于子组件继承父组件的事件）</li></ul> <p>A组件（<code>APP.vue</code>）：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token operator">&lt;</span>template<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">&quot;app&quot;</span><span class="token operator">&gt;</span>
        <span class="token comment">//此处监听了两个事件，可以在B组件或者C组件中直接触发 </span>
        <span class="token operator">&lt;</span>child1 <span class="token operator">:</span>p<span class="token operator">-</span>child1<span class="token operator">=</span><span class="token string">&quot;child1&quot;</span> <span class="token operator">:</span>p<span class="token operator">-</span>child2<span class="token operator">=</span><span class="token string">&quot;child2&quot;</span> @test1<span class="token operator">=</span><span class="token string">&quot;onTest1&quot;</span> @test2<span class="token operator">=</span><span class="token string">&quot;onTest2&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>child1<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
<span class="token keyword">import</span> Child1 <span class="token keyword">from</span> <span class="token string">'./Child1.vue'</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
    components<span class="token operator">:</span> <span class="token punctuation">{</span> Child1 <span class="token punctuation">}</span><span class="token punctuation">,</span>
    methods<span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token function">onTest1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'test1 running'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token function">onTest2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'test2 running'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>B组件（<code>Child1.vue</code>）：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token operator">&lt;</span>template<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">&quot;child-1&quot;</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>props<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span>pChild1<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>$attrs<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span>$attrs<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>child2 v<span class="token operator">-</span>bind<span class="token operator">=</span><span class="token string">&quot;$attrs&quot;</span> v<span class="token operator">-</span>on<span class="token operator">=</span><span class="token string">&quot;$listeners&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>child2<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
<span class="token keyword">import</span> Child2 <span class="token keyword">from</span> <span class="token string">'./Child2.vue'</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
    props<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'pChild1'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    components<span class="token operator">:</span> <span class="token punctuation">{</span> Child2 <span class="token punctuation">}</span><span class="token punctuation">,</span>
    inheritAttrs<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'test1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 触发APP.vue中的test1方法</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>C 组件 (<code>Child2.vue</code>)：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token operator">&lt;</span>template<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">&quot;child-2&quot;</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>props<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span>pChild2<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>$attrs<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span>$attrs<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
    props<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'pChild2'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    inheritAttrs<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'test2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 触发APP.vue中的test2方法</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>在上述代码中：</p> <ul><li>C组件中能直接触发test的原因在于 B组件调用C组件时 使用 v-on 绑定了<code>$listeners</code> 属性</li> <li>在B组件中通过v-bind 绑定<code>$attrs</code>属性，C组件可以直接获取到A组件中传递下来的props（除了B组件中props声明的）</li></ul> <h3 id="_6-总结"><a href="#_6-总结" class="header-anchor">#</a> （6）总结</h3> <p><strong>（1）父子组件间通信</strong></p> <ul><li>子组件通过 props 属性来接受父组件的数据，然后父组件在子组件上注册监听事件，子组件通过 emit 触发事件来向父组件发送数据。</li> <li>通过 ref 属性给子组件设置一个名字。父组件通过 $refs 组件名来获得子组件，子组件通过 $parent 获得父组件，这样也可以实现通信。</li> <li>使用 provide/inject，在父组件中通过 provide提供变量，在子组件中通过 inject 来将变量注入到组件中。不论子组件有多深，只要调用了 inject 那么就可以注入 provide中的数据。</li></ul> <p><strong>（2）兄弟组件间通信</strong></p> <ul><li>使用 eventBus 的方法，它的本质是通过创建一个空的 Vue 实例来作为消息传递的对象，通信的组件引入这个实例，通信的组件通过在这个实例上监听和触发事件，来实现消息的传递。</li> <li>通过 $parent/$refs 来获取到兄弟组件，也可以进行通信。</li></ul> <p><strong>（3）任意组件之间</strong></p> <ul><li>使用 eventBus ，其实就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。</li></ul> <p>如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候采用上面这一些方法可能不利于项目的维护。这个时候可以使用 vuex ，vuex 的思想就是将这一些公共的数据抽离出来，将它作为一个全局的变量来管理，然后其他组件就可以对这个公共数据进行读写操作，这样达到了解耦的目的。</p> <h3 id="vue的优点"><a href="#vue的优点" class="header-anchor">#</a> vue的优点</h3> <p>轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十kb；</p> <p>简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；</p> <p>双向数据绑定：保留了angular的特点，在数据操作方面更为简单；</p> <p>组件化：保留了react的优点，实现了html的封装和重用，在构建单页面应用方面有着独特的优势；</p> <p>视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；</p> <p>虚拟DOM：dom操作是非常耗费性能的，不再使用原生的dom操作节点，极大解放dom操作，但具体操作的还是dom不过是换了另一种方式；</p> <p>运行速度更快:相比较与react而言，同样是操作虚拟dom，就性能而言，vue存在很大的优势。</p> <h3 id="请详细说下你对vue生命周期的理解"><a href="#请详细说下你对vue生命周期的理解" class="header-anchor">#</a> 请详细说下你对vue生命周期的理解？</h3> <p>总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后。</p> <blockquote><p>创建前/后： 在beforeCreate阶段，vue实例的挂载元素el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，el为undefined，还未初始化。</p></blockquote> <blockquote><p>载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。</p></blockquote> <blockquote><p>更新前/后：当data变化时，会触发beforeUpdate和updated方法</p></blockquote> <blockquote><p>销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在</p></blockquote> <h3 id="为什么vue组件中data必须是一个函数"><a href="#为什么vue组件中data必须是一个函数" class="header-anchor">#</a> 为什么vue组件中data必须是一个函数？</h3> <p>对象为引用类型，当复用组件时，由于数据对象都指向同一个data对象，当在一个组件中修改data时，其他重用的组件中的data会同时被修改；而使用返回对象的函数，由于每次返回的都是一个新对象（Object的实例），引用地址不同，则不会出现这个问题。</p> <h3 id="vue中v-if和v-show有什么区别"><a href="#vue中v-if和v-show有什么区别" class="header-anchor">#</a> vue中v-if和v-show有什么区别？</h3> <p>v-if和v-show看起来似乎差不多，当条件不成立时，其所对应的标签元素都不可见，但是这两个选项是有区别的:</p> <p>1、v-if在条件切换时，会对标签进行适当的创建和销毁，而v-show则仅在初始化时加载一次，因此v-if的开销相对来说会比v-show大。</p> <p>2、v-if是惰性的，只有当条件为真时才会真正渲染标签；如果初始条件不为真，则v-if不会去渲染标签。v-show则无论初始条件是否成立，都会渲染标签，它仅仅做的只是简单的CSS切换。</p> <h3 id="computed和watch的区别-2"><a href="#computed和watch的区别-2" class="header-anchor">#</a> computed和watch的区别</h3> <h4 id="计算属性computed"><a href="#计算属性computed" class="header-anchor">#</a> 计算属性computed：</h4> <ul><li>支持缓存，只有依赖数据发生改变，才会重新进行计算</li> <li>不支持异步，当computed内有异步操作时无效，无法监听数据的变化</li> <li>computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值</li> <li>如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed</li> <li>如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。</li></ul> <h4 id="侦听属性watch"><a href="#侦听属性watch" class="header-anchor">#</a> 侦听属性watch：</h4> <ul><li>不支持缓存，数据变，直接会触发相应的操作；</li> <li>watch支持异步；</li> <li>监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；</li> <li>当一个属性发生变化时，需要执行对应的操作；一对多；</li> <li>监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数：</li></ul> <blockquote><p>immediate：组件加载立即触发回调函数执行</p></blockquote> <div class="language- line-numbers-mode"><pre class="language-text"><code>watch: {
  firstName: {
    handler(newName, oldName) {
      this.fullName = newName + ' ' + this.lastName;
    },
    // 代表在wacth里声明了firstName这个方法之后立即执行handler方法
    immediate: true
  }
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><blockquote><p>deep: deep的意思就是深入观察，监听器会一层层的往下遍历，给对象的所有属性都加上这个监听器，但是这样性能开销就会非常大了，任何修改obj里面任何一个属性都会触发这个监听器里的 handler</p></blockquote> <div class="language- line-numbers-mode"><pre class="language-text"><code>watch: {
  obj: {
    handler(newName, oldName) {
      console.log('obj.a changed');
    },
    immediate: true,
    deep: true
  }
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>优化：我们可以使用字符串的形式监听</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>watch: {
  'obj.a': {
    handler(newName, oldName) {
      console.log('obj.a changed');
    },
    immediate: true,
    // deep: true
  }
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>这样Vue.js才会一层一层解析下去，直到遇到属性a，然后才给a设置监听函数。</p> <h3 id="vue-loader是什么-使用它的用途有哪些"><a href="#vue-loader是什么-使用它的用途有哪些" class="header-anchor">#</a> vue-loader是什么？使用它的用途有哪些？</h3> <p>vue文件的一个加载器，跟template/js/style转换成js模块。</p> <h3 id="nexttick是什么"><a href="#nexttick是什么" class="header-anchor">#</a> $nextTick是什么？</h3> <p>vue实现响应式并不是数据发生变化后dom立即变化，而是按照一定的策略来进行dom更新。</p> <blockquote><p>nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用nextTick，则可以在回调中获取更新后的 DOM</p></blockquote> <h3 id="v-for-key的作用"><a href="#v-for-key的作用" class="header-anchor">#</a> v-for key的作用</h3> <p>当Vue用 v-for 正在更新已渲染过的元素列表是，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue将不是移动DOM元素来匹配数据项的改变，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。</p> <p>为了给Vue一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。key属性的类型只能为 string或者number类型。</p> <p>key 的特殊属性主要用在Vue的虚拟DOM算法，在新旧nodes对比时辨识VNodes。如果不使用 key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。使用key，它会基于key的变化重新排列元素顺序，并且会移除 key 不存在的元素。</p> <h3 id="vue的双向数据绑定原理是什么"><a href="#vue的双向数据绑定原理是什么" class="header-anchor">#</a> Vue的双向数据绑定原理是什么？</h3> <p>vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤：</p> <blockquote><p>1、需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化</p></blockquote> <blockquote><p>2、compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</p></blockquote> <blockquote><p>3、Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: ①在自身实例化时往属性订阅器(dep)里面添加自己 ②自身必须有一个update()方法 ③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。</p></blockquote> <blockquote><p>4、MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</p></blockquote> <h3 id="组件传值"><a href="#组件传值" class="header-anchor">#</a> 组件传值</h3> <h4 id="父传子"><a href="#父传子" class="header-anchor">#</a> 父传子</h4> <p>通过props传递</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>父组件： &lt;child value = '传递的数据' /&gt;

子组件: props['value'],接收数据,接受之后使用和data中定义数据使用方式一样

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h4 id="子传父"><a href="#子传父" class="header-anchor">#</a> 子传父</h4> <p>在父组件中给子组件绑定一个自定义的事件，子组件通过$emit()触发该事件并传值。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>父组件： &lt;child @receive = 'receive' /&gt;

 子组件: this.$emit('receive','传递的数据')

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h4 id="兄弟组件传值"><a href="#兄弟组件传值" class="header-anchor">#</a> 兄弟组件传值</h4> <ul><li>通过中央通信 let bus = new Vue()</li></ul> <blockquote><p>A：methods :{ 函数{bus.$emit(‘自定义事件名’，数据)} 发送</p></blockquote> <blockquote><p>B：created （）{bus.$on(‘A发送过来的自定义事件名’，函数)} 进行数据接收</p></blockquote> <ul><li>通过vuex</li></ul> <h3 id="prop-验证-和默认值"><a href="#prop-验证-和默认值" class="header-anchor">#</a> prop 验证，和默认值</h3> <p>我们在父组件给子组件传值的时候，可以指定该props的默认值及类型，当传递数据类型不正确的时候，vue会发出警告</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>props: {
    visible: {
        default: true,
        type: Boolean,
        required: true
    },
},

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="请说下封装-vue-组件的过程"><a href="#请说下封装-vue-组件的过程" class="header-anchor">#</a> 请说下封装 vue 组件的过程</h3> <p>首先，组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立的模块，解决了我们传统项目开发：效率低、难维护、复用性等问题。</p> <p>然后，使用Vue.extend方法创建一个组件，然后使用Vue.component方法注册组件。子组件需要数据，可以在props中接受定义。而子组件修改好数据后，想把数据传递给父组件。可以采用emit方法。</p> <h3 id="vue-js的template编译"><a href="#vue-js的template编译" class="header-anchor">#</a> Vue.js的template编译</h3> <p>简而言之，就是先转化成AST树，再得到的render函数返回VNode（Vue的虚拟DOM节点），详细步骤如下：</p> <blockquote><p>首先，通过compile编译器把template编译成AST语法树（abstract syntax tree 即 源代码的抽象语法结构的树状表现形式），compile是createCompiler的返回值，createCompiler是用以创建编译器的。另外compile还负责合并option。</p></blockquote> <blockquote><p>然后，AST会经过generate（将AST语法树转化成render funtion字符串的过程）得到render函数，render的返回值是VNode，VNode是Vue的虚拟DOM节点，里面有（标签名、子节点、文本等等）</p></blockquote> <h3 id="scss是什么-在vue-cli中的安装使用步骤是-有哪几大特性"><a href="#scss是什么-在vue-cli中的安装使用步骤是-有哪几大特性" class="header-anchor">#</a> scss是什么？在vue.cli中的安装使用步骤是？有哪几大特性？</h3> <p>css的预编译,使用步骤如下：</p> <p>第一步：用npm 下三个loader（sass-loader、css-loader、node-sass）</p> <p>第二步：在build目录找到webpack.base.config.js，在那个extends属性中加一个拓展.scss</p> <p>第三步：还是在同一个文件，配置一个module属性</p> <p>第四步：然后在组件的style标签加上lang属性 ，例如：lang=”scss”</p> <p>特性主要有:</p> <ul><li>可以用变量，例如（$变量名称=值）</li> <li>可以用混合器，例如（）</li> <li>可以嵌套</li></ul> <h3 id="vue如何监听对象或者数组某个属性的变化"><a href="#vue如何监听对象或者数组某个属性的变化" class="header-anchor">#</a> vue如何监听对象或者数组某个属性的变化</h3> <p>当在项目中直接设置数组的某一项的值，或者直接设置对象的某个属性值，这个时候，你会发现页面并没有更新。这是因为Object.defineProperty()限制，监听不到变化。</p> <p>解决方式：</p> <ul><li>this.$set(你要改变的数组/对象，你要改变的位置/key，你要改成什么value)</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>this.$set(this.arr, 0, &quot;OBKoro1&quot;); // 改变数组
this.$set(this.obj, &quot;c&quot;, &quot;OBKoro1&quot;); // 改变对象

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li>调用以下几个数组的方法</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>splice()、 push()、pop()、shift()、unshift()、sort()、reverse()

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>vue源码里缓存了array的原型链，然后重写了这几个方法，触发这几个方法的时候会observer数据，意思是使用这些方法不用我们再进行额外的操作，视图自动进行更新。 推荐使用splice方法会比较好自定义,因为splice可以在数组的任何位置进行删除/添加操作</p> <h3 id="常用的事件修饰符"><a href="#常用的事件修饰符" class="header-anchor">#</a> 常用的事件修饰符</h3> <ul><li>.stop:阻止冒泡</li> <li>.prevent:阻止默认行为</li> <li>.self:仅绑定元素自身触发</li> <li>.once: 2.1.4 新增,只触发一次</li> <li>passive: 2.3.0 新增,滚动事件的默认行为 (即滚动行为) 将会立即触发,不能和.prevent 一起使用</li> <li>.sync 修饰符</li></ul> <p>从 2.3.0 起vue重新引入了.sync修饰符，但是这次它只是作为一个编译时的语法糖存在。它会被扩展为一个自动更新父组件属性的 v-on 监听器。示例代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;comp :foo.sync=&quot;bar&quot;&gt;&lt;/comp&gt;

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>会被扩展为：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;comp :foo=&quot;bar&quot; @update:foo=&quot;val =&gt; bar = val&quot;&gt;&lt;/comp&gt;

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>当子组件需要更新 foo 的值时，它需要显式地触发一个更新事件：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>this.$emit('update:foo', newValue)

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="vue如何获取dom"><a href="#vue如何获取dom" class="header-anchor">#</a> vue如何获取dom</h3> <p>先给标签设置一个ref值，再通过this.$refs.domName获取，例如：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;div ref=&quot;test&quot;&gt;&lt;/div&gt;

const dom = this.$refs.test

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="v-on可以监听多个方法吗"><a href="#v-on可以监听多个方法吗" class="header-anchor">#</a> v-on可以监听多个方法吗？</h3> <p>是可以的，来个例子：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;input type=&quot;text&quot; v-on=&quot;{ input:onInput,focus:onFocus,blur:onBlur, }&quot;&gt;

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="assets和static的区别"><a href="#assets和static的区别" class="header-anchor">#</a> assets和static的区别</h3> <p>这两个都是用来存放项目中所使用的静态资源文件。</p> <p>两者的区别：</p> <p>assets中的文件在运行npm run build的时候会打包，简单来说就是会被压缩体积，代码格式化之类的。打包之后也会放到static中。</p> <p>static中的文件则不会被打包。</p> <blockquote><p>建议：将图片等未处理的文件放在assets中，打包减少体积。而对于第三方引入的一些资源文件如iconfont.css等可以放在static中，因为这些文件已经经过处理了。</p></blockquote> <h3 id="slot插槽"><a href="#slot插槽" class="header-anchor">#</a> slot插槽</h3> <p>很多时候，我们封装了一个子组件之后，在父组件使用的时候，想添加一些dom元素，这个时候就可以使用slot插槽了，但是这些dom是否显示以及在哪里显示，则是看子组件中slot组件的位置了。</p> <h3 id="vue初始化页面闪动问题"><a href="#vue初始化页面闪动问题" class="header-anchor">#</a> vue初始化页面闪动问题</h3> <p>使用vue开发时，在vue初始化之前，由于div是不归vue管的，所以我们写的代码在还没有解析的情况下会容易出现花屏现象，看到类似于的字样，虽然一般情况下这个时间很短暂，但是我们还是有必要让解决这个问题的。</p> <p>首先：在css里加上以下代码</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>[v-cloak] {
    display: none;
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>如果没有彻底解决问题，则在根元素加上style=&quot;display: none;&quot; :style=&quot;{display: 'block'}&quot;</p> <h2 id="vue插件篇"><a href="#vue插件篇" class="header-anchor">#</a> vue插件篇</h2> <h3 id="状态管理-vuex"><a href="#状态管理-vuex" class="header-anchor">#</a> 状态管理（vuex）</h3> <h4 id="vuex是什么"><a href="#vuex是什么" class="header-anchor">#</a> vuex是什么</h4> <p>Vuex 是一个专为 Vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。</p> <h4 id="怎么使用vuex"><a href="#怎么使用vuex" class="header-anchor">#</a> 怎么使用vuex</h4> <p>第一步安装</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>npm install vuex -S

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>第二步创建store</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>import Vue from 'vue';
import Vuex from 'vuex';
Vue.use(Vuex);
//不是在生产环境debug为true
const debug = process.env.NODE_ENV !== 'production';
//创建Vuex实例对象
const store = new Vuex.Store({
    strict:debug,//在不是生产环境下都开启严格模式
    state:{
    },
    getters:{
    },
    mutations:{
    },
    actions:{
    }
})
export default store;

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>第三步注入vuex</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>import Vue from 'vue';
import App from './App.vue';
import store from './store';
const vm = new Vue({
    store:store,
    render: h =&gt; h(App)
}).$mount('#app')

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h4 id="vuex中有几个核心属性-分别是什么"><a href="#vuex中有几个核心属性-分别是什么" class="header-anchor">#</a> vuex中有几个核心属性，分别是什么？</h4> <p>一共有5个核心属性，分别是:</p> <ul><li>state 唯一数据源,Vue 实例中的 data 遵循相同的规则</li> <li>getters 可以认为是 store 的计算属性,就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。Getter 会暴露为 store.getters 对象，你可以以属性的形式访问这些值.</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>const store = new Vuex.Store({
  state: {
    todos: [
      { id: 1, text: '...', done: true },
      { id: 2, text: '...', done: false }
    ]
  },
  getters: {
    doneTodos: state =&gt; {
      return state.todos.filter(todo =&gt; todo.done)
    }
  }
})

store.getters.doneTodos // -&gt; [{ id: 1, text: '...', done: true }]

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><ul><li>mutation 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation,非常类似于事件,通过store.commit 方法触发</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>const store = new Vuex.Store({
  state: {
    count: 1
  },
  mutations: {
    increment (state) {
      // 变更状态
      state.count++
    }
  }
})

store.commit('increment')

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><ul><li>action Action 类似于 mutation，不同在于Action 提交的是 mutation，而不是直接变更状态，Action 可以包含任意异步操作</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>const store = new Vuex.Store({
  state: {
    count: 0
  },
  mutations: {
    increment (state) {
      state.count++
    }
  },
  actions: {
    increment (context) {
      context.commit('increment')
    }
  }
})

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><ul><li>module  由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>const moduleA = {
  state: () =&gt; ({ ... }),
  mutations: { ... },
  actions: { ... },
  getters: { ... }
}

const moduleB = {
  state: () =&gt; ({ ... }),
  mutations: { ... },
  actions: { ... }
}

const store = new Vuex.Store({
  modules: {
    a: moduleA,
    b: moduleB
  }
})

store.state.a // -&gt; moduleA 的状态
store.state.b // -&gt; moduleB 的状态

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><h4 id="ajax请求代码应该写在组件的methods中还是vuex的actions中"><a href="#ajax请求代码应该写在组件的methods中还是vuex的actions中" class="header-anchor">#</a> ajax请求代码应该写在组件的methods中还是vuex的actions中</h4> <p>如果请求来的数据是不是要被其他组件公用，仅仅在请求的组件内使用，就不需要放入vuex 的state里。</p> <p>如果被其他地方复用，这个很大几率上是需要的，如果需要，请将请求放入action里，方便复用。</p> <h4 id="从vuex中获取的数据能直接更改吗"><a href="#从vuex中获取的数据能直接更改吗" class="header-anchor">#</a> 从vuex中获取的数据能直接更改吗？</h4> <p>从vuex中取的数据，不能直接更改，需要浅拷贝对象之后更改，否则报错；</p> <h4 id="vuex中的数据在页面刷新后数据消失"><a href="#vuex中的数据在页面刷新后数据消失" class="header-anchor">#</a> vuex中的数据在页面刷新后数据消失</h4> <p>用sessionstorage 或者 localstorage 存储数据</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>存储： sessionStorage.setItem( '名', JSON.stringify(值) )
使用： sessionStorage.getItem('名') ---得到的值为字符串类型，用JSON.parse()去引号；

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>也可以引入插件vuex-persist，使用方法如下：</p> <ul><li>安装</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>npm install --save vuex-persist
or
yarn add vuex-persist

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li>引入</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>import VuexPersistence from 'vuex-persist'

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ul><li>先创建一个对象并进行配置</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>const vuexLocal = new VuexPersistence({
    storage: window.localStorage
})

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li>引入进vuex插件</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>const store = new Vuex.Store({
  state: { ... },
  mutations: { ... },
  actions: { ... },
  plugins: [vuexLocal.plugin]
}) 

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>通过以上设置，在图3中各个页面之间跳转，如果刷新某个视图，数据并不会丢失，依然存在，并且不需要在每个 mutations 中手动存取 storage 。</p> <h4 id="vuex的严格模式是什么-有什么作用-怎么开启"><a href="#vuex的严格模式是什么-有什么作用-怎么开启" class="header-anchor">#</a> Vuex的严格模式是什么,有什么作用,怎么开启？</h4> <p>在严格模式下，无论何时发生了状态变更且不是由mutation函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。</p> <p>在Vuex.Store 构造器选项中开启,如下</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const store = new Vuex.Store({
    strict:true,
})

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h4 id="怎么在组件中批量使用vuex的getter属性"><a href="#怎么在组件中批量使用vuex的getter属性" class="header-anchor">#</a> 怎么在组件中批量使用Vuex的getter属性</h4> <p>使用mapGetters辅助函数, 利用对象展开运算符将getter混入computed 对象中</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>import {mapGetters} from 'vuex'
export default{
    computed:{
        ...mapGetters(['total','discountTotal'])
    }
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h4 id="组件中重复使用mutation"><a href="#组件中重复使用mutation" class="header-anchor">#</a> 组件中重复使用mutation</h4> <p>使用mapMutations辅助函数,在组件中这么使用</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>import { mapMutations } from 'vuex'
methods:{
    ...mapMutations({
        setNumber:'SET_NUMBER',
    })
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>然后调用this.setNumber(10)相当调用this.$store.commit('SET_NUMBER',10)</p> <h4 id="mutation和action有什么区别"><a href="#mutation和action有什么区别" class="header-anchor">#</a> mutation和action有什么区别</h4> <ul><li>action 提交的是 mutation，而不是直接变更状态。mutation可以直接变更状态</li> <li>action 可以包含任意异步操作。mutation只能是同步操作</li> <li>提交方式不同</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>action 是用this.store.dispatch('ACTION_NAME',data)来提交。
mutation是用this.$store.commit('SET_NUMBER',10)来提交

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li>接收参数不同，mutation第一个参数是state，而action第一个参数是context，其包含了</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>{
    state,      // 等同于 `store.state`，若在模块中则为局部状态
    rootState,  // 等同于 `store.state`，只存在于模块中
    commit,     // 等同于 `store.commit`
    dispatch,   // 等同于 `store.dispatch`
    getters,    // 等同于 `store.getters`
    rootGetters // 等同于 `store.getters`，只存在于模块中
}


</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h4 id="在v-model上怎么用vuex中state的值"><a href="#在v-model上怎么用vuex中state的值" class="header-anchor">#</a> 在v-model上怎么用Vuex中state的值？</h4> <p>需要通过computed计算属性来转换。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;input v-model=&quot;message&quot;&gt;
// ...
computed: {
    message: {
        get () {
            return this.$store.state.message
        },
        set (value) {
            this.$store.commit('updateMessage', value)
        }
    }
}


</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h3 id="路由页面管理-vue-router"><a href="#路由页面管理-vue-router" class="header-anchor">#</a> 路由页面管理（vue-router）</h3> <h4 id="什么是vue-router"><a href="#什么是vue-router" class="header-anchor">#</a> 什么是vue-router</h4> <p>Vue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。包含的功能有：</p> <ul><li>嵌套的路由/视图表</li> <li>模块化的、基于组件的路由配置</li> <li>路由参数、查询、通配符</li> <li>基于 Vue.js 过渡系统的视图过渡效果</li> <li>细粒度的导航控制</li> <li>带有自动激活的 CSS class 的链接</li> <li>HTML5 历史模式或 hash 模式，在 IE9 中自动降级</li> <li>自定义的滚动条行为</li></ul> <h4 id="怎么使用vue-router"><a href="#怎么使用vue-router" class="header-anchor">#</a> 怎么使用vue-router</h4> <p>第一步安装</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>npm install vue-router -S
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>第二步在main.js中使用Vue Router组件</p> <p><code>![img](_image/01.vue相关汇总/1734d65dc240568e)</code></p> <p>第三步配置路由</p> <ul><li>定义 (路由) 组件</li></ul> <p>路由组件可以是直接定义，也可以是导入已经定义好的组件。这里导入已经定义好的组件。如下</p> <p><code>![img](_image/01.vue相关汇总/1734d65dc2668cc8)</code></p> <ul><li>定义路由（路由对象数组）</li></ul> <p>定义路由对象数组。对象的path是自定义的路径（即使用这个路径可以找到对应的组件），component是指该路由对应的组件。如下：</p> <p><code>![img](_image/01.vue相关汇总/1734d65dc3da62ed)</code></p> <ul><li>实例化Vue Router对象</li></ul> <p>调用Vue Router的构造方法创建一个Vue Router的实例对象，将上一步定义的路由对象数组作为参数对象的值传入。如下</p> <p><code>![img](_image/01.vue相关汇总/1734d65dc48e8bf4)</code></p> <ul><li>挂载根实例</li></ul> <p><code>![img](_image/01.vue相关汇总/1734d65dcb5f42d7)</code></p> <p>第四步在App.vue中使用路由</p> <p>在App.vue中使用标签来显示路由对应的组件，使用标签指定当点击时显示的对应的组件，to属性就是指定组件对应的路由。如下：</p> <p><code>![img](_image/01.vue相关汇总/1734d65dc512c1e6)</code></p> <h4 id="怎么定义vue-router的动态路由-怎么获取传过来的动态参数"><a href="#怎么定义vue-router的动态路由-怎么获取传过来的动态参数" class="header-anchor">#</a> 怎么定义vue-router的动态路由？怎么获取传过来的动态参数？</h4> <p>在router目录下的index.js文件中，对path属性加上/:id。使用router对象的params.id获取动态参数</p> <h4 id="vue-router的导航钩子"><a href="#vue-router的导航钩子" class="header-anchor">#</a> vue-router的导航钩子</h4> <p>常用的是router.beforeEach(to,from,next)，在跳转前进行权限判断。一共有三种：</p> <ul><li>全局导航钩子：router.beforeEach(to,from,next)</li> <li>组件内的钩子</li> <li>单独路由独享组件</li></ul> <h4 id="vue路由传参"><a href="#vue路由传参" class="header-anchor">#</a> vue路由传参</h4> <blockquote><p>使用query方法传入的参数使用this.$route.query接受</p></blockquote> <blockquote><p>使用params方式传入的参数使用this.$route.params接受</p></blockquote> <h4 id="router和route的区别"><a href="#router和route的区别" class="header-anchor">#</a> router和route的区别</h4> <blockquote><p>route为当前router跳转对象里面可以获取name、path、query、params等</p></blockquote> <blockquote><p>router为VueRouter实例，想要导航到不同URL，则使用router.push方法</p></blockquote> <h4 id="路由-typeerror-cannot-read-property-matched-of-undefined-的错误问题"><a href="#路由-typeerror-cannot-read-property-matched-of-undefined-的错误问题" class="header-anchor">#</a> 路由 TypeError: Cannot read property 'matched' of undefined 的错误问题</h4> <p>找到入口文件main.js里的new Vue()，必须使用router名，不能把router改成Router或者其他的别名</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 引入路由
import router from './routers/router.js'

new Vue({
    el: '#app',
    router,    // 这个名字必须使用router
    render: h =&gt; h(App)
});


</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h4 id="路由按需加载"><a href="#路由按需加载" class="header-anchor">#</a> 路由按需加载</h4> <p>随着项目功能模块的增加，引入的文件数量剧增。如果不做任何处理，那么首屏加载会相当的缓慢，这个时候，路由按需加载就闪亮登场了。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>webpack&lt; 2.4 时
{ 
    path:'/', 
    name:'home',
    components:resolve=&gt;require(['@/components/home'],resolve)
} 
webpack&gt; 2.4 时
{ 
    path:'/', 
    name:'home', 
    components:()=&gt;import('@/components/home')
}


</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>import()方法是由es6提出的，动态加载返回一个Promise对象，then方法的参数是加载到的模块。类似于Node.js的require方法，主要import()方法是异步加载的。</p> <h4 id="vue里面router-link在电脑上有用-在安卓上没反应怎么解决"><a href="#vue里面router-link在电脑上有用-在安卓上没反应怎么解决" class="header-anchor">#</a> Vue里面router-link在电脑上有用，在安卓上没反应怎么解决</h4> <p>Vue路由在Android机上有问题，babel问题，安装babel polypill插件解决</p> <h4 id="vue2中注册在router-link上事件无效解决方法"><a href="#vue2中注册在router-link上事件无效解决方法" class="header-anchor">#</a> Vue2中注册在router-link上事件无效解决方法</h4> <p>使用@click.native。原因：router-link会阻止click事件，.native指直接监听一个原生事件</p> <h4 id="routerlink在ie和firefox中不起作用-路由不跳转-的问题"><a href="#routerlink在ie和firefox中不起作用-路由不跳转-的问题" class="header-anchor">#</a> RouterLink在IE和Firefox中不起作用（路由不跳转）的问题</h4> <ul><li>只用a标签，不使用button标签</li> <li>使用button标签和Router.navigate方法</li></ul> <h3 id="网络请求-axios"><a href="#网络请求-axios" class="header-anchor">#</a> 网络请求(axios)</h3> <p>这个模块请看我的另一篇文章，此处不再整理（我太懒了）</p> <p><a href="https://juejin.im/post/6847009771606769677" target="_blank" rel="noopener noreferrer">学会了axios封装，世界都是你的<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="视频播放-video-js"><a href="#视频播放-video-js" class="header-anchor">#</a> 视频播放(video.js)</h3> <p>这个模块请看我的另一篇文章，此处不再整理（我太懒了）</p> <p><a href="https://juejin.im/post/6850037269227634702" target="_blank" rel="noopener noreferrer">手把手从零开始---封装一个vue视频播放器组件<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="vue常用ui库"><a href="#vue常用ui库" class="header-anchor">#</a> vue常用ui库</h3> <h4 id="移动端"><a href="#移动端" class="header-anchor">#</a> 移动端</h4> <ul><li>mint-ui （http://mint-ui.github.io/#!/zh-cn）</li> <li>Vant（https://youzan.github.io/vant/#/zh-CN/home）</li> <li>VUX (https://vux.li/)</li></ul> <h4 id="pc端"><a href="#pc端" class="header-anchor">#</a> pc端</h4> <ul><li>element-ui（https://element.eleme.cn/2.13/#/zh-CN/component/installation）</li> <li>Ant Design of Vue（https://www.antdv.com/docs/vue/introduce-cn/）</li> <li>Avue (https://avuejs.com/)</li></ul> <h2 id="常用webpack配置"><a href="#常用webpack配置" class="header-anchor">#</a> 常用webpack配置</h2> <h3 id="vue-lic3脚手架-vue-config-js"><a href="#vue-lic3脚手架-vue-config-js" class="header-anchor">#</a> vue-lic3脚手架（vue.config.js）</h3> <h4 id="publicpath"><a href="#publicpath" class="header-anchor">#</a> publicPath</h4> <p>类型：String</p> <p>默认：'/'</p> <p>部署应用包时的基本 URL。默认情况下，Vue CLI会假设你的应用是被部署在一个域名的根路径上，例如https://www.my-app.com/。如果应用被部署在一个子路径上，你就需要用这个选项指定这个子路径。例如，如果你的应用被部署在https://www.my-app.com/my-app/，则设置publicPath为/my-app/</p> <p>这个值也可以被设置为空字符串 ('') 或是相对路径 ('./')，这样所有的资源都会被链接为相对路径，这样打出来的包可以被部署在任意路径，也可以用在类似 Cordova hybrid 应用的文件系统中。</p> <h4 id="productionsourcemap"><a href="#productionsourcemap" class="header-anchor">#</a> productionSourceMap</h4> <p>类型：boolean</p> <p>moren：true</p> <p>不允许打包时生成项目来源映射文件，在生产环境下可以显著的减少包的体积</p> <blockquote><p>注 Source map的作用：针对打包后的代码进行的处理，就是一个信息文件，里面储存着位置信息。也就是说，转换后的代码的每一个位置，所对应的转换前的位置。有了它，出错的时候，除错工具将直接显示原始代码，而不是转换后的代码。这无疑给开发者带来了很大方便</p></blockquote> <h4 id="assetsdir"><a href="#assetsdir" class="header-anchor">#</a> assetsDir</h4> <p>放置生成的静态资源 (js、css、img、fonts) 的 (相对于 outputDir 的) 目录,默认是'',</p> <h4 id="indexpath"><a href="#indexpath" class="header-anchor">#</a> indexPath</h4> <p>指定生成的 index.html 的输出路径(相对于outputDir)。也可以是一个绝对路径。默认是'index.html'</p> <h4 id="lintonsave"><a href="#lintonsave" class="header-anchor">#</a> lintOnSave</h4> <p>是否在每次保存时使用eslint检查，这个对语法的要求比较严格，对自己有要求的同学可以使用</p> <h4 id="css"><a href="#css" class="header-anchor">#</a> css</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>css: {
    //是否启用css分离插件，默认是true，如果不启用css样式分离插件，打包出来的css是通过内联样式的方式注入至dom中的，
    extract: true,
    sourceMap: false,//效果同上
    modules: false,// 为所有的 CSS 及其预处理文件开启 CSS Modules。
    // 这个选项不会影响 `*.vue` 文件。
  },
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h4 id="devserver"><a href="#devserver" class="header-anchor">#</a> devServer</h4> <p>本地开发服务器配置，此处直接贴上我常用的配置，以注释的方式介绍</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>devServer: { 
    //配置开发服务器
    host: &quot;0.0.0.0&quot;,
    //是否启用热加载，就是每次更新代码，是否需要重新刷新浏览器才能看到新代码效果
    hot: true,
    //服务启动端口
    port: &quot;8080&quot;,
    //是否自动打开浏览器默认为false
    open: false,
    //配置http代理
    proxy: { 
      &quot;/api&quot;: { //如果ajax请求的地址是http://192.168.0.118:9999/api1那么你就可以在jajx中使用/api/api1路径,其请求路径会解析
        // http://192.168.0.118:9999/api1，当然你在浏览器上开到的还是http://localhost:8080/api/api1;
        target: &quot;http://192.168.0.118:9999&quot;,
        //是否允许跨域，这里是在开发环境会起作用，但在生产环境下，还是由后台去处理，所以不必太在意
        changeOrigin: true,
        pathRewrite: {
            //把多余的路径置为''
          &quot;api&quot;: &quot;&quot;
        }
      },
      &quot;/api2&quot;: {//可以配置多个代理，匹配上那个就使用哪种解析方式
        target: &quot;http://api2&quot;,
        // ...
      }
    }
},


</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><h4 id="pluginoptions"><a href="#pluginoptions" class="header-anchor">#</a> pluginOptions</h4> <p>这是一个不进行任何 schema 验证的对象，因此它可以用来传递任何第三方插件选项，例如：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>{
    //定义一个全局的less文件，把公共样式变量放入其中，这样每次使用的时候就不用重新引用了
    'style-resources-loader': {
      preProcessor: 'less',
      patterns: [
        './src/assets/public.less'
      ]
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h4 id="chainwebpack"><a href="#chainwebpack" class="header-anchor">#</a> chainWebpack</h4> <p>是一个函数，会接收一个基于 webpack-chain 的 ChainableConfig 实例。允许对内部的 webpack 配置进行更细粒度的修改。例如：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>chainWebpack(config) { 
//添加一个路径别名 假设有在assets/img/menu/目录下有十张图片，如果全路径require(&quot;/assets/img/menu/img1.png&quot;)
//去引入在不同的层级下实在是太不方便了，这时候向下方一样定义一个路劲别名就很实用了
    config.resolve.alias
      //添加多个别名支持链式调用
      .set(&quot;assets&quot;, path.join(__dirname, &quot;/src/assets&quot;))
      .set(&quot;img&quot;, path.join(__dirname, &quot;/src/assets/img/menu&quot;))
      //引入图片时只需require(&quot;img/img1.png&quot;);即可
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="_1、说说你对-spa-单页面的理解-它的优缺点分别是什么"><a href="#_1、说说你对-spa-单页面的理解-它的优缺点分别是什么" class="header-anchor">#</a> 1、说说你对 SPA 单页面的理解，它的优缺点分别是什么？</h2> <p>SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。</p> <p><strong>优点：</strong></p> <ul><li>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；</li> <li>基于上面一点，SPA 相对对服务器压力小；</li> <li>前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；</li></ul> <p><strong>缺点：</strong></p> <ul><li>初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；</li> <li>前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；</li> <li>SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。</li></ul> <h2 id="_2、v-show-与-v-if-有什么区别"><a href="#_2、v-show-与-v-if-有什么区别" class="header-anchor">#</a> 2、v-show 与 v-if 有什么区别？</h2> <p><strong>v-if</strong> 是<strong>真正</strong>的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是<strong>惰性的</strong>：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p> <p><strong>v-show</strong> 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 “display” 属性进行切换。</p> <p>所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。</p> <h2 id="_3、class-与-style-如何动态绑定"><a href="#_3、class-与-style-如何动态绑定" class="header-anchor">#</a> 3、Class 与 Style 如何动态绑定？</h2> <p>Class 可以通过对象语法和数组语法进行动态绑定：</p> <ul><li>对象语法：</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;div v-bind:class=&quot;{ active: isActive, 'text-danger': hasError }&quot;&gt;&lt;/div&gt;

data: {
  isActive: true,
  hasError: false
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ul><li>数组语法：</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;div v-bind:class=&quot;[isActive ? activeClass : '', errorClass]&quot;&gt;&lt;/div&gt;

data: {
  activeClass: 'active',
  errorClass: 'text-danger'
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>Style 也可以通过对象语法和数组语法进行动态绑定：</p> <ul><li>对象语法：</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;div v-bind:style=&quot;{ color: activeColor, fontSize: fontSize + 'px' }&quot;&gt;&lt;/div&gt;

data: {
  activeColor: 'red',
  fontSize: 30
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ul><li>数组语法：</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;div v-bind:style=&quot;[styleColor, styleSize]&quot;&gt;&lt;/div&gt;

data: {
  styleColor: {
     color: 'red'
   },
  styleSize:{
     fontSize:'23px'
  }
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="_4、怎样理解-vue-的单向数据流"><a href="#_4、怎样理解-vue-的单向数据流" class="header-anchor">#</a> 4、怎样理解 Vue 的单向数据流？</h2> <p>所有的 prop 都使得其父子 prop 之间形成了一个<strong>单向下行绑定</strong>：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p> <p>额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。</p> <p>有两种常见的试图改变一个 prop 的情形 :</p> <ul><li><strong>这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。</strong> 在这种情况下，最好定义一个本地的 data 属性并将这个 prop 用作其初始值：</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>props: ['initialCounter'],
data: function () {
  return {
    counter: this.initialCounter
  }
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ul><li><strong>这个 prop 以一种原始的值传入且需要进行转换。</strong> 在这种情况下，最好使用这个 prop 的值来定义一个计算属性</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>props: ['size'],
computed: {
  normalizedSize: function () {
    return this.size.trim().toLowerCase()
  }
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="_5、computed-和-watch-的区别和运用的场景"><a href="#_5、computed-和-watch-的区别和运用的场景" class="header-anchor">#</a> 5、computed 和 watch 的区别和运用的场景？</h2> <p><strong>computed：</strong> 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed  的值；</p> <p><strong>watch：</strong> 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；</p> <p><strong>运用场景：</strong></p> <ul><li>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</li> <li>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</li></ul> <h2 id="_6、直接给一个数组项赋值-vue-能检测到变化吗"><a href="#_6、直接给一个数组项赋值-vue-能检测到变化吗" class="header-anchor">#</a> 6、直接给一个数组项赋值，Vue 能检测到变化吗？</h2> <p>由于 JavaScript 的限制，Vue 不能检测到以下数组的变动：</p> <ul><li>当你利用索引直接设置一个数组项时，例如：<code>vm.items[indexOfItem] = newValue</code></li> <li>当你修改数组的长度时，例如：<code>vm.items.length = newLength</code></li></ul> <p>为了解决第一个问题，Vue 提供了以下操作方法：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// Vue.set
Vue.set(vm.items, indexOfItem, newValue)
// vm.$set，Vue.set的一个别名
vm.$set(vm.items, indexOfItem, newValue)
// Array.prototype.splice
vm.items.splice(indexOfItem, 1, newValue)

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>为了解决第二个问题，Vue 提供了以下操作方法：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// Array.prototype.splice
vm.items.splice(newLength)

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="_7、谈谈你对-vue-生命周期的理解"><a href="#_7、谈谈你对-vue-生命周期的理解" class="header-anchor">#</a> 7、谈谈你对 Vue 生命周期的理解？</h2> <p><strong>（1）生命周期是什么？</strong></p> <p>Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载 Dom -&gt; 渲染、更新 -&gt; 渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。</p> <p><strong>（2）各个生命周期的作用</strong></p> <table><thead><tr><th>生命周期</th> <th>描述</th></tr></thead> <tbody><tr><td>beforeCreate</td> <td>组件实例被创建之初，组件的属性生效之前</td></tr> <tr><td>created</td> <td>组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用</td></tr> <tr><td>beforeMount</td> <td>在挂载开始之前被调用：相关的 render 函数首次被调用</td></tr> <tr><td>mounted</td> <td>el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子</td></tr> <tr><td>beforeUpdate</td> <td>组件数据更新之前调用，发生在虚拟 DOM 打补丁之前</td></tr> <tr><td>update</td> <td>组件数据更新之后</td></tr> <tr><td>activited</td> <td>keep-alive 专属，组件被激活时调用</td></tr> <tr><td>deactivated</td> <td>keep-alive 专属，组件被销毁时调用</td></tr> <tr><td>beforeDestory</td> <td>组件销毁前调用</td></tr> <tr><td>destoryed</td> <td>组件销毁后调用</td></tr></tbody></table> <p><strong>（3）生命周期示意图</strong></p> <p><code>![1.png](_image/01.vue相关汇总/16ca74f183827f46)</code></p> <h2 id="_8、vue-的父组件和子组件生命周期钩子函数执行顺序"><a href="#_8、vue-的父组件和子组件生命周期钩子函数执行顺序" class="header-anchor">#</a> 8、Vue 的父组件和子组件生命周期钩子函数执行顺序？</h2> <p>Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分：</p> <ul><li><p>加载渲染过程</p> <p>父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</p></li> <li><p>子组件更新过程</p> <p>父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</p></li> <li><p>父组件更新过程</p> <p>父 beforeUpdate -&gt; 父 updated</p></li> <li><p>销毁过程</p> <p>父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</p></li></ul> <h2 id="_9、在哪个生命周期内调用异步请求"><a href="#_9、在哪个生命周期内调用异步请求" class="header-anchor">#</a> 9、在哪个生命周期内调用异步请求？</h2> <p>可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。但是本人推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：</p> <ul><li>能更快获取到服务端数据，减少页面 loading 时间；</li> <li>ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；</li></ul> <h2 id="_10、在什么阶段才能访问操作dom"><a href="#_10、在什么阶段才能访问操作dom" class="header-anchor">#</a> 10、在什么阶段才能访问操作DOM？</h2> <p>在钩子函数 mounted 被调用前，Vue 已经将编译好的模板挂载到页面上，所以在 mounted 中可以访问操作 DOM。vue 具体的生命周期示意图可以参见如下，理解了整个生命周期各个阶段的操作，关于生命周期相关的面试题就难不倒你了。</p> <p><code>![1.png](_image/01.vue相关汇总/16ca74f183827f46)</code></p> <h2 id="_11、父组件可以监听到子组件的生命周期吗"><a href="#_11、父组件可以监听到子组件的生命周期吗" class="header-anchor">#</a> 11、父组件可以监听到子组件的生命周期吗？</h2> <p>比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理，可以通过以下写法实现：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// Parent.vue
&lt;Child @mounted=&quot;doSomething&quot;/&gt;
    
// Child.vue
mounted() {
  this.$emit(&quot;mounted&quot;);
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>以上需要手动通过 $emit 触发父组件的事件，更简单的方式可以在父组件引用子组件时通过 @hook 来监听即可，如下所示：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>//  Parent.vue
&lt;Child @hook:mounted=&quot;doSomething&quot; &gt;&lt;/Child&gt;

doSomething() {
   console.log('父组件监听到 mounted 钩子函数 ...');
},
    
//  Child.vue
mounted(){
   console.log('子组件触发 mounted 钩子函数 ...');
},    
    
// 以上输出顺序为：
// 子组件触发 mounted 钩子函数 ...
// 父组件监听到 mounted 钩子函数 ...     

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>当然 @hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听。</p> <h2 id="_12、谈谈你对-keep-alive-的了解"><a href="#_12、谈谈你对-keep-alive-的了解" class="header-anchor">#</a> 12、谈谈你对 keep-alive 的了解？</h2> <p>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性：</p> <ul><li>一般结合路由和动态组件一起使用，用于缓存组件；</li> <li>提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；</li> <li>对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。</li></ul> <h2 id="_13、组件中-data-为什么是一个函数"><a href="#_13、组件中-data-为什么是一个函数" class="header-anchor">#</a> 13、组件中 data 为什么是一个函数？</h2> <blockquote><p>为什么组件中的 data 必须是一个函数，然后 return 一个对象，而 new Vue 实例里，data 可以直接是一个对象？</p></blockquote> <div class="language- line-numbers-mode"><pre class="language-text"><code>// data
data() {
  return {
	message: &quot;子组件&quot;,
	childName:this.name
  }
}

// new Vue
new Vue({
  el: '#app',
  router,
  template: '&lt;App/&gt;',
  components: {App}
})


</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>因为组件是用来复用的，且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响，如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响；而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。</p> <h2 id="_14、v-model-的原理"><a href="#_14、v-model-的原理" class="header-anchor">#</a> 14、v-model 的原理？</h2> <p>我们在 vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，我们知道 v-model 本质上不过是语法糖，v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：</p> <ul><li>text 和 textarea 元素使用 value 属性和 input 事件；</li> <li>checkbox 和 radio 使用 checked 属性和 change 事件；</li> <li>select 字段将 value 作为 prop 并将 change 作为事件。</li></ul> <p>以 input  表单元素为例：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;input v-model='something'&gt;
    
相当于

&lt;input v-bind:value=&quot;something&quot; v-on:input=&quot;something = $event.target.value&quot;&gt;

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>如果在自定义组件中，v-model 默认会利用名为 value 的 prop 和名为 input 的事件，如下所示：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>父组件：
&lt;ModelChild v-model=&quot;message&quot;&gt;&lt;/ModelChild&gt;

子组件：
&lt;div&gt;{{value}}&lt;/div&gt;

props:{
    value: String
},
methods: {
  test1(){
     this.$emit('input', '小红')
  },
},

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h2 id="_15、vue-组件间通信有哪几种方式"><a href="#_15、vue-组件间通信有哪几种方式" class="header-anchor">#</a> 15、Vue 组件间通信有哪几种方式？</h2> <p>Vue 组件间通信是面试常考的知识点之一，这题有点类似于开放题，你回答出越多方法当然越加分，表明你对 Vue 掌握的越熟练。Vue 组件间通信只要指以下 3 类通信：父子组件通信、隔代组件通信、兄弟组件通信，下面我们分别介绍每种通信方式且会说明此种方法可适用于哪类组件间通信。</p> <p><strong>（1）<code>props / $emit</code>  适用 父子组件通信</strong></p> <p>这种方法是 Vue 组件的基础，相信大部分同学耳闻能详，所以此处就不举例展开介绍。</p> <p><strong>（2）<code>ref</code> 与 <code>$parent / $children</code> 适用 父子组件通信</strong></p> <ul><li><code>ref</code>：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例</li> <li><code>$parent</code> / <code>$children</code>：访问父 / 子实例</li></ul> <p><strong>（3）<code>EventBus （$emit / $on）</code>  适用于 父子、隔代、兄弟组件通信</strong></p> <p>这种方法通过一个空的 Vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件。</p> <p><strong>（4）<code>$attrs</code>/<code>$listeners</code> 适用于 隔代组件通信</strong></p> <ul><li><code>$attrs</code>：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过 <code>v-bind=&quot;$attrs&quot;</code> 传入内部组件。通常配合 inheritAttrs 选项一起使用。</li> <li><code>$listeners</code>：包含了父作用域中的 (不含 .native 修饰器的)  v-on 事件监听器。它可以通过 <code>v-on=&quot;$listeners&quot;</code> 传入内部组件</li></ul> <p><strong>（5）<code>provide / inject</code> 适用于 隔代组件通信</strong></p> <p>祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。 provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。</p> <p><strong>（6）Vuex  适用于 父子、隔代、兄弟组件通信</strong></p> <p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。</p> <ul><li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li> <li>改变 store 中的状态的唯一途径就是显式地提交  (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。</li></ul> <h2 id="_16、你使用过-vuex-吗"><a href="#_16、你使用过-vuex-吗" class="header-anchor">#</a> 16、你使用过 Vuex 吗？</h2> <p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。</p> <p>（1）Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</p> <p>（2）改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。</p> <p>主要包括以下几个模块：</p> <ul><li>State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。</li> <li>Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。</li> <li>Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。</li> <li>Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。</li> <li>Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。</li></ul> <h2 id="_17、使用过-vue-ssr-吗-说说-ssr"><a href="#_17、使用过-vue-ssr-吗-说说-ssr" class="header-anchor">#</a> 17、使用过 Vue SSR 吗？说说 SSR？</h2> <blockquote><p>Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记&quot;激活&quot;为客户端上完全可交互的应用程序。</p> <p>即：SSR大致的意思就是vue在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的html 片段直接返回给客户端这个过程就叫做服务端渲染。</p></blockquote> <p><strong>服务端渲染 SSR 的优缺点如下：</strong></p> <p><strong>（1）服务端渲染的优点：</strong></p> <ul><li>更好的 SEO： 因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；</li> <li>更快的内容到达时间（首屏加载更快）： SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间；</li></ul> <p><strong>（2) 服务端渲染的缺点：</strong></p> <ul><li>更多的开发条件限制： 例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；</li> <li>更多的服务器负载：在 Node.js  中渲染完整的应用程序，显然会比仅仅提供静态文件的  server 更加大量占用CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic ) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。</li></ul> <p>如果没有 SSR 开发经验的同学，可以参考本文作者的另一篇 SSR 的实践文章<a href="https://juejin.im/post/6844903824956588040" target="_blank" rel="noopener noreferrer">《Vue SSR 踩坑之旅》<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，里面 SSR 项目搭建以及附有项目源码。</p> <h2 id="_18、vue-router-路由模式有几种"><a href="#_18、vue-router-路由模式有几种" class="header-anchor">#</a> 18、vue-router 路由模式有几种？</h2> <p>vue-router 有 3 种路由模式：hash、history、abstract，对应的源码如下所示：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>switch (mode) {
  case 'history':
	this.history = new HTML5History(this, options.base)
	break
  case 'hash':
	this.history = new HashHistory(this, options.base, this.fallback)
	break
  case 'abstract':
	this.history = new AbstractHistory(this, options.base)
	break
  default:
	if (process.env.NODE_ENV !== 'production') {
	  assert(false, `invalid mode: ${mode}`)
	}
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>其中，3 种路由模式的说明如下：</p> <ul><li>hash:  使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器；</li> <li>history :  依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式；</li> <li>abstract :  支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.</li></ul> <h2 id="_19、能说下-vue-router-中常用的-hash-和-history-路由模式实现原理吗"><a href="#_19、能说下-vue-router-中常用的-hash-和-history-路由模式实现原理吗" class="header-anchor">#</a> 19、能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？</h2> <p><strong>（1）hash 模式的实现原理</strong></p> <p>早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为 '#search'：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>https://www.word.com#search

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>hash  路由模式的实现主要是基于下面几个特性：</p> <ul><li>URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送；</li> <li>hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换；</li> <li>可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用  JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值；</li> <li>我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。</li></ul> <p><strong>（2）history 模式的实现原理</strong></p> <p>HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>window.history.pushState(null, null, path);
window.history.replaceState(null, null, path);

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>history 路由模式的实现主要基于存在下面几个特性：</p> <ul><li>pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ；</li> <li>我们可以使用 popstate  事件来监听 url 的变化，从而对页面进行跳转（渲染）；</li> <li>history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。</li></ul> <h2 id="_20、什么是-mvvm"><a href="#_20、什么是-mvvm" class="header-anchor">#</a> 20、什么是 MVVM？</h2> <p>Model–View–ViewModel （MVVM） 是一个软件架构设计模式，由微软 WPF 和 Silverlight 的架构师 Ken Cooper 和 Ted Peters 开发，是一种简化用户界面的事件驱动编程方式。由 John Gossman（同样也是 WPF 和 Silverlight 的架构师）于2005年在他的博客上发表</p> <p>MVVM 源自于经典的 Model–View–Controller（MVC）模式  ，MVVM 的出现促进了前端开发与后端业务逻辑的分离，极大地提高了前端开发效率，MVVM 的核心是 ViewModel 层，它就像是一个中转站（value converter），负责转换 Model 中的数据对象来让数据变得更容易管理和使用，该层向上与视图层进行双向数据绑定，向下与 Model 层通过接口请求进行数据交互，起呈上启下作用。如下图所示：</p> <p><code>![1.png](_image/01.vue相关汇总/16ca75871ec53fba)</code></p> <p>（1）View 层</p> <p>View 是视图层，也就是用户界面。前端主要由 HTML 和 CSS 来构建 。</p> <p>（2）Model 层</p> <p>Model 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，对于前端来说就是后端提供的 api 接口。</p> <p>（3）ViewModel 层</p> <p>ViewModel 是由前端开发人员组织生成和维护的视图数据层。在这一层，前端开发者对从后端获取的 Model 数据进行转换处理，做二次封装，以生成符合 View 层使用预期的视图数据模型。需要注意的是 ViewModel 所封装出来的数据模型包括视图的状态和行为两部分，而 Model 层的数据模型是只包含状态的，比如页面的这一块展示什么，而页面加载进来时发生什么，点击这一块发生什么，这一块滚动时发生什么这些都属于视图行为（交互），视图状态和行为都封装在了 ViewModel 里。这样的封装使得 ViewModel 可以完整地去描述 View 层。</p> <p>MVVM 框架实现了双向绑定，这样 ViewModel 的内容会实时展现在 View 层，前端开发者再也不必低效又麻烦地通过操纵 DOM 去更新视图，MVVM 框架已经把最脏最累的一块做好了，我们开发者只需要处理和维护 ViewModel，更新数据视图就会自动得到相应更新。这样 View 层展现的不是 Model 层的数据，而是 ViewModel 的数据，由 ViewModel 负责与 Model 层交互，这就完全解耦了 View 层和 Model 层，这个解耦是至关重要的，它是前后端分离方案实施的重要一环。</p> <p>我们以下通过一个 Vue 实例来说明 MVVM 的具体实现，有 Vue 开发经验的同学应该一目了然：</p> <p>（1）View 层</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;div id=&quot;app&quot;&gt;
    &lt;p&gt;{{message}}&lt;/p&gt;
    &lt;button v-on:click=&quot;showMessage()&quot;&gt;Click me&lt;/button&gt;
&lt;/div&gt;

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>（2）ViewModel 层</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var app = new Vue({
    el: '#app',
    data: {  // 用于描述视图状态   
        message: 'Hello Vue!', 
    },
    methods: {  // 用于描述视图行为  
        showMessage(){
            let vm = this;
            alert(vm.message);
        }
    },
    created(){
        let vm = this;
        // Ajax 获取 Model 层的数据
        ajax({
            url: '/your/server/data/api',
            success(res){
                vm.message = res;
            }
        });
    }
})

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><p>（3） Model 层</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>{
    &quot;url&quot;: &quot;/your/server/data/api&quot;,
    &quot;res&quot;: {
        &quot;success&quot;: true,
        &quot;name&quot;: &quot;IoveC&quot;,
        &quot;domain&quot;: &quot;www.cnblogs.com&quot;
    }
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="_21、vue-是如何实现数据双向绑定的"><a href="#_21、vue-是如何实现数据双向绑定的" class="header-anchor">#</a> 21、Vue 是如何实现数据双向绑定的？</h2> <p>Vue 数据双向绑定主要是指：数据变化更新视图，视图变化更新数据，如下图所示：</p> <p>![1.png](data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="492" height="153"></svg>)</p> <p>即：</p> <ul><li>输入框内容变化时，Data 中的数据同步变化。即 View =&gt; Data 的变化。</li> <li>Data 中的数据变化时，文本节点的内容同步变化。即 Data =&gt; View 的变化。</li></ul> <p>其中，View 变化更新 Data ，可以通过事件监听的方式来实现，所以 Vue 的数据双向绑定的工作主要是如何根据 Data 变化更新 View。</p> <p>Vue 主要通过以下 4 个步骤来实现数据双向绑定的：</p> <p>实现一个监听器 Observer：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。</p> <p>实现一个解析器 Compile：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。</p> <p>实现一个订阅者 Watcher：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。</p> <p>实现一个订阅器 Dep：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。</p> <p>以上四个步骤的流程图表示如下，如果有同学理解不大清晰的，可以查看作者专门介绍数据双向绑定的文章<a href="https://juejin.im/post/6844903903822086151" target="_blank" rel="noopener noreferrer">《0 到 1 掌握：Vue 核心之数据双向绑定》<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，有进行详细的讲解、以及代码 demo 示例。</p> <p><code>![1.png](_image/01.vue相关汇总/16ca75871f729d89)</code></p> <h2 id="_22、vue-框架怎么实现对象和数组的监听"><a href="#_22、vue-框架怎么实现对象和数组的监听" class="header-anchor">#</a> 22、Vue 框架怎么实现对象和数组的监听？</h2> <p>如果被问到 Vue 怎么实现数据双向绑定，大家肯定都会回答 通过 Object.defineProperty() 对数据进行劫持，但是  Object.defineProperty() 只能对属性进行数据劫持，不能对整个对象进行劫持，同理无法对数组进行劫持，但是我们在使用 Vue 框架中都知道，Vue 能检测到对象和数组（部分方法的操作）的变化，那它是怎么实现的呢？我们查看相关代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  /**
   * Observe a list of Array items.
   */
  observeArray (items: Array&lt;any&gt;) {
    for (let i = 0, l = items.length; i &lt; l; i++) {
      observe(items[i])  // observe 功能为监测数据的变化
    }
  }

  /**
   * 对属性进行递归遍历
   */
  let childOb = !shallow &amp;&amp; observe(val) // observe 功能为监测数据的变化


</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>通过以上 Vue 源码部分查看，我们就能知道 Vue 框架是通过遍历数组 和递归遍历对象，从而达到利用  Object.defineProperty() 也能对对象和数组（部分方法的操作）进行监听。</p> <h2 id="_23、proxy-与-object-defineproperty-优劣对比"><a href="#_23、proxy-与-object-defineproperty-优劣对比" class="header-anchor">#</a> 23、Proxy 与 Object.defineProperty 优劣对比</h2> <p><strong>Proxy 的优势如下:</strong></p> <ul><li>Proxy 可以直接监听对象而非属性；</li> <li>Proxy 可以直接监听数组的变化；</li> <li>Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的；</li> <li>Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；</li> <li>Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利；</li></ul> <p><strong>Object.defineProperty 的优势如下:</strong></p> <ul><li>兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重写。</li></ul> <h2 id="_24、vue-怎么用-vm-set-解决对象新增属性不能响应的问题"><a href="#_24、vue-怎么用-vm-set-解决对象新增属性不能响应的问题" class="header-anchor">#</a> 24、Vue 怎么用 vm.$set() 解决对象新增属性不能响应的问题 ？</h2> <p>受现代 JavaScript 的限制 ，Vue <strong>无法检测到对象属性的添加或删除</strong>。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。但是 Vue 提供了 <code>Vue.set (object, propertyName, value) / vm.$set (object, propertyName, value)</code>  来实现为对象添加响应式属性，那框架本身是如何实现的呢？</p> <p>我们查看对应的 Vue 源码：<code>vue/src/core/instance/index.js</code></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export function set (target: Array&lt;any&gt; | Object, key: any, val: any): any {
  // target 为数组  
  if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) {
    // 修改数组的长度, 避免索引&gt;数组长度导致splcie()执行有误
    target.length = Math.max(target.length, key)
    // 利用数组的splice变异方法触发响应式  
    target.splice(key, 1, val)
    return val
  }
  // key 已经存在，直接修改属性值  
  if (key in target &amp;&amp; !(key in Object.prototype)) {
    target[key] = val
    return val
  }
  const ob = (target: any).__ob__
  // target 本身就不是响应式数据, 直接赋值
  if (!ob) {
    target[key] = val
    return val
  }
  // 对属性进行响应式处理
  defineReactive(ob.value, key, val)
  ob.dep.notify()
  return val
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p>我们阅读以上源码可知，vm.$set 的实现原理是：</p> <ul><li>如果目标是数组，直接使用数组的 splice 方法触发相应式；</li> <li>如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用   defineReactive 方法进行响应式处理（ defineReactive 方法就是  Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法）</li></ul> <h2 id="_25、虚拟-dom-的优缺点"><a href="#_25、虚拟-dom-的优缺点" class="header-anchor">#</a> 25、虚拟 DOM 的优缺点？</h2> <p><strong>优点：</strong></p> <ul><li><strong>保证性能下限：</strong> 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；</li> <li><strong>无需手动操作 DOM：</strong> 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；</li> <li><strong>跨平台：</strong> 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。</li></ul> <p><strong>缺点:</strong></p> <ul><li><strong>无法进行极致优化：</strong> 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。</li></ul> <h2 id="_26、虚拟-dom-实现原理"><a href="#_26、虚拟-dom-实现原理" class="header-anchor">#</a> 26、虚拟 DOM 实现原理？</h2> <p>虚拟 DOM 的实现原理主要包括以下 3 部分：</p> <ul><li>用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；</li> <li>diff 算法 — 比较两棵虚拟 DOM 树的差异；</li> <li>pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。</li></ul> <p>如果对以上 3 个部分还不是很了解的同学，可以查看本文作者写的另一篇详解虚拟 DOM 的文章《<a href="https://juejin.im/post/6844903895467032589#heading-14" target="_blank" rel="noopener noreferrer">深入剖析：Vue核心之虚拟DOM<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>》</p> <h2 id="_27、vue-中的-key-有什么作用"><a href="#_27、vue-中的-key-有什么作用" class="header-anchor">#</a> 27、Vue 中的 key 有什么作用？</h2> <p>key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速。Vue 的 diff 过程可以概括为：oldCh 和 newCh 各有两个头尾的变量 oldStartIndex、oldEndIndex 和 newStartIndex、newEndIndex，它们会新节点和旧节点会进行两两对比，即一共有4种比较方式：newStartIndex 和oldStartIndex 、newEndIndex 和  oldEndIndex 、newStartIndex 和 oldEndIndex 、newEndIndex 和 oldStartIndex，如果以上 4 种比较都没匹配，如果设置了key，就会用 key 再进行比较，在比较的过程中，遍历会往中间靠，一旦 StartIdx &gt; EndIdx 表明 oldCh 和 newCh 至少有一个已经遍历完了，就会结束比较。具体有无 key 的 diff 过程，可以查看作者写的另一篇详解虚拟 DOM 的文章《<a href="https://juejin.im/post/6844903895467032589#heading-14" target="_blank" rel="noopener noreferrer">深入剖析：Vue核心之虚拟DOM<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>》</p> <p>所以 Vue 中 key 的作用是：key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速</p> <p><strong>更准确</strong>：因为带 key 就不是就地复用了，在 sameNode 函数 <code>a.key === b.key</code> 对比中可以避免就地复用的情况。所以会更加准确。</p> <p><strong>更快速</strong>：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快，源码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function createKeyToOldIdx (children, beginIdx, endIdx) {
  let i, key
  const map = {}
  for (i = beginIdx; i &lt;= endIdx; ++i) {
    key = children[i].key
    if (isDef(key)) map[key] = i
  }
  return map
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h2 id="_28、你有对-vue-项目进行哪些优化"><a href="#_28、你有对-vue-项目进行哪些优化" class="header-anchor">#</a> 28、你有对 Vue 项目进行哪些优化？</h2> <p>如果没有对 Vue 项目没有进行过优化总结的同学，可以参考本文作者的另一篇文章<a href="https://juejin.im/post/6844903913410314247" target="_blank" rel="noopener noreferrer">《 Vue 项目性能优化 — 实践指南 》<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，文章主要介绍从 3 个大方面，22 个小方面详细讲解如何进行 Vue 项目的优化。</p> <p><strong>（1）代码层面的优化</strong></p> <ul><li>v-if 和 v-show 区分使用场景</li> <li>computed 和 watch  区分使用场景</li> <li>v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</li> <li>长列表性能优化</li> <li>事件的销毁</li> <li>图片资源懒加载</li> <li>路由懒加载</li> <li>第三方插件的按需引入</li> <li>优化无限列表性能</li> <li>服务端渲染 SSR or 预渲染</li></ul> <p><strong>（2）Webpack 层面的优化</strong></p> <ul><li>Webpack 对图片进行压缩</li> <li>减少 ES6 转为 ES5 的冗余代码</li> <li>提取公共代码</li> <li>模板预编译</li> <li>提取组件的 CSS</li> <li>优化 SourceMap</li> <li>构建结果输出分析</li> <li>Vue 项目的编译优化</li></ul> <p><strong>（3）基础的 Web 技术的优化</strong></p> <ul><li>开启 gzip 压缩</li> <li>浏览器缓存</li> <li>CDN 的使用</li> <li>使用 Chrome Performance 查找性能瓶颈</li></ul> <h2 id="_29、对于即将到来的-vue3-0-特性你有什么了解的吗"><a href="#_29、对于即将到来的-vue3-0-特性你有什么了解的吗" class="header-anchor">#</a> 29、对于即将到来的 vue3.0 特性你有什么了解的吗？</h2> <p>Vue 3.0 正走在发布的路上，Vue 3.0 的目标是让 Vue 核心变得更小、更快、更强大，因此 Vue 3.0 增加以下这些新特性：</p> <p><strong>（1）监测机制的改变</strong></p> <p>3.0 将带来基于代理 Proxy 的 observer 实现，提供全语言覆盖的反应性跟踪。这消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制：</p> <ul><li>只能监测属性，不能监测对象</li> <li>检测属性的添加和删除；</li> <li>检测数组索引和长度的变更；</li> <li>支持 Map、Set、WeakMap 和 WeakSet。</li></ul> <p>新的 observer 还提供了以下特性：</p> <ul><li>用于创建 observable 的公开 API。这为中小规模场景提供了简单轻量级的跨组件状态管理解决方案。</li> <li>默认采用惰性观察。在 2.x 中，不管反应式数据有多大，都会在启动时被观察到。如果你的数据集很大，这可能会在应用启动时带来明显的开销。在 3.x 中，只观察用于渲染应用程序最初可见部分的数据。</li> <li>更精确的变更通知。在 2.x 中，通过 Vue.set 强制添加新属性将导致依赖于该对象的 watcher 收到变更通知。在 3.x 中，只有依赖于特定属性的 watcher 才会收到通知。</li> <li>不可变的 observable：我们可以创建值的“不可变”版本（即使是嵌套属性），除非系统在内部暂时将其“解禁”。这个机制可用于冻结 prop 传递或 Vuex 状态树以外的变化。</li> <li>更好的调试功能：我们可以使用新的 renderTracked 和 renderTriggered 钩子精确地跟踪组件在什么时候以及为什么重新渲染。</li></ul> <p><strong>（2）模板</strong></p> <p>模板方面没有大的变更，只改了作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。</p> <p>同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。</p> <p><strong>（3）对象式的组件声明方式</strong></p> <p>vue2.x 中的组件是通过声明的方式传入一系列 option，和 TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 TypeScript 的结合变得很容易。</p> <p>此外，vue 的源码也改用了 TypeScript 来写。其实当代码的功能复杂之后，必须有一个静态类型系统来做一些辅助管理。现在 vue3.0 也全面改用 TypeScript 来重写了，更是使得对外暴露的 api 更容易结合 TypeScript。静态类型系统对于复杂代码的维护确实很有必要。</p> <p><strong>（4）其它方面的更改</strong></p> <p>vue3.0 的改变是全面的，上面只涉及到主要的 3 个方面，还有一些其他的更改：</p> <ul><li>支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。</li> <li>支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。</li> <li>基于 treeshaking 优化，提供了更多的内置功能。</li></ul> <h2 id="_30、说说你使用-vue-框架踩过最大的坑是什么-怎么解决的"><a href="#_30、说说你使用-vue-框架踩过最大的坑是什么-怎么解决的" class="header-anchor">#</a> 30、说说你使用 Vue 框架踩过最大的坑是什么？怎么解决的？</h2> <p>本题为开放题目，欢迎大家在评论区畅所欲言，分享自己的踩坑、填坑经历，提供前车之鉴，避免大伙再次踩坑 ~~~</p> <h2 id="来-先介绍一下vue的响应式系统"><a href="#来-先介绍一下vue的响应式系统" class="header-anchor">#</a> 来，先介绍一下Vue的响应式系统</h2> <p>Vue为MVVM框架，当数据模型data变化时，页面视图会得到响应更新，其原理对data的getter/setter方法进行拦截（Object.defineProperty或者Proxy），利用发布订阅的设计模式，在getter方法中进行订阅，在setter方法中发布通知，让所有订阅者完成响应。</p> <p>在响应式系统中，Vue会为数据模型data的每一个属性新建一个订阅中心作为发布者，而监听器watch、计算属性computed、视图渲染template/render三个角色同时作为订阅者，对于监听器watch，会直接订阅观察监听的属性，对于计算属性computed和视图渲染template/render，如果内部执行获取了data的某个属性，就会执行该属性的getter方法，然后自动完成对该属性的订阅，当属性被修改时，就会执行该属性的setter方法，从而完成该属性的发布通知，通知所有订阅者进行更新。</p> <h2 id="computed与watch的区别"><a href="#computed与watch的区别" class="header-anchor">#</a> computed与watch的区别</h2> <p>计算属性computed和监听器watch都可以观察属性的变化从而做出响应，不同的是：</p> <p>计算属性computed更多是作为缓存功能的观察者，它可以将一个或者多个data的属性进行复杂的计算生成一个新的值，提供给渲染函数使用，当依赖的属性变化时，computed不会立即重新计算生成新的值，而是先标记为脏数据，当下次computed被获取时候，才会进行重新计算并返回。</p> <p>而监听器watch并不具备缓存性，监听器watch提供一个监听函数，当监听的属性发生变化时，会立即执行该函数。</p> <h2 id="介绍一下vue的生命周期"><a href="#介绍一下vue的生命周期" class="header-anchor">#</a> 介绍一下Vue的生命周期</h2> <p><code>beforeCreate</code>：是new Vue()之后触发的第一个钩子，在当前阶段data、methods、computed以及watch上的数据和方法都不能被访问。</p> <p><code>created</code>：在实例创建完成后发生，当前阶段已经完成了数据观测，也就是可以使用数据，更改数据，在这里更改数据不会触发updated函数。可以做一些初始数据的获取，在当前阶段无法与Dom进行交互，如果非要想，可以通过vm.$nextTick来访问Dom。</p> <p><code>beforeMount</code>：发生在挂载之前，在这之前template模板已导入渲染函数编译。而当前阶段虚拟Dom已经创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发updated。</p> <p><code>mounted</code>：在挂载完成后发生，在当前阶段，真实的Dom挂载完毕，数据完成双向绑定，可以访问到Dom节点，使用$refs属性对Dom进行操作。</p> <p><code>beforeUpdate</code>：发生在更新之前，也就是响应式数据发生更新，虚拟dom重新渲染之前被触发，你可以在当前阶段进行更改数据，不会造成重渲染。</p> <p><code>updated</code>：发生在更新完成之后，当前阶段组件Dom已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新。</p> <p><code>beforeDestroy</code>：发生在实例销毁之前，在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器。</p> <p><code>destroyed</code>：发生在实例销毁之后，这个时候只剩下了dom空壳。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。</p> <h2 id="为什么组件的data必须是一个函数"><a href="#为什么组件的data必须是一个函数" class="header-anchor">#</a> 为什么组件的data必须是一个函数</h2> <p>一个组件可能在很多地方使用，也就是会创建很多个实例，如果data是一个对象的话，对象是引用类型，一个实例修改了data会影响到其他实例，所以data必须使用函数，为每一个实例创建一个属于自己的data，使其同一个组件的不同实例互不影响。</p> <h2 id="组件之间是怎么通信的"><a href="#组件之间是怎么通信的" class="header-anchor">#</a> 组件之间是怎么通信的</h2> <ul><li>父子组件通信</li></ul> <p>父组件 -&gt; 子组件：<code>prop</code></p> <p>子组件 -&gt; 父组件：<code>$on/$emit</code></p> <p>获取组件实例：使用<code>$parent/$children</code>，<code>$refs.xxx</code>，获取到实例后直接获取属性数据或调用组件方法</p> <ul><li>兄弟组件通信</li></ul> <p>Event Bus：每一个Vue实例都是一个Event Bus，都支持<code>$on/$emit</code>，可以为兄弟组件的实例之间new一个Vue实例，作为Event Bus进行通信。</p> <p>Vuex：将状态和方法提取到Vuex，完成共享</p> <ul><li>跨级组件通信</li></ul> <p>使用provide/inject</p> <p>Event Bus：同兄弟组件Event Bus通信</p> <p>Vuex：将状态和方法提取到Vuex，完成共享</p> <h2 id="vue事件绑定原理说一下"><a href="#vue事件绑定原理说一下" class="header-anchor">#</a> Vue事件绑定原理说一下</h2> <p>每一个Vue实例都是一个Event Bus，当子组件被创建的时候，父组件将事件传递给子组件，子组件初始化的时候是有<code>$on</code>方法将事件注册到内部，在需要的时候使用<code>$emit</code>触发函数，而对于原生native事件，使用addEventListener绑定到真实的DOM元素上。</p> <h2 id="slot是什么-有什么作用-原理是什么-2"><a href="#slot是什么-有什么作用-原理是什么-2" class="header-anchor">#</a> slot是什么？有什么作用？原理是什么？</h2> <p>slot又名插槽，是Vue的内容分发机制，组件内部的模板引擎使用slot元素作为承载分发内容的出口。插槽slot是子组件的一个模板标签元素，而这一个标签元素是否显示，以及怎么显示是由父组件决定的。</p> <p>slot又分三类，默认插槽，具名插槽和作用域插槽。</p> <ul><li>默认插槽：又名匿名查抄，当slot没有指定name属性值的时候一个默认显示插槽，一个组件内只有有一个匿名插槽。</li> <li>具名插槽：带有具体名字的插槽，也就是带有name属性的slot，一个组件可以出现多个具名插槽。</li> <li>作用域插槽：默认插槽、具名插槽的一个变体，可以是匿名插槽，也可以是具名插槽，该插槽的不同点是在子组件渲染作用域插槽时，可以将子组件内部的数据传递给父组件，让父组件根据子组件的传递过来的数据决定如何渲染该插槽。</li></ul> <p>实现原理：当子组件vm实例化时，获取到父组件传入的slot标签的内容，存放在<code>vm.$slot</code>中，默认插槽为<code>vm.$slot.default</code>，具名插槽为<code>vm.$slot.xxx</code>，xxx 为插槽名，当组件执行渲染函数时候，遇到slot标签，使用<code>$slot</code>中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可称该插槽为作用域插槽。</p> <h2 id="vue模板渲染的原理是什么"><a href="#vue模板渲染的原理是什么" class="header-anchor">#</a> Vue模板渲染的原理是什么？</h2> <p>vue中的模板template无法被浏览器解析并渲染，因为这不属于浏览器的标准，不是正确的HTML语法，所有需要将template转化成一个JavaScript函数，这样浏览器就可以执行这一个函数并渲染出对应的HTML元素，就可以让视图跑起来了，这一个转化的过程，就成为模板编译。</p> <p>模板编译又分三个阶段，解析parse，优化optimize，生成generate，最终生成可执行函数render。</p> <ul><li>parse阶段：使用大量的正则表达式对template字符串进行解析，将标签、指令、属性等转化为抽象语法树AST。</li> <li>optimize阶段：遍历AST，找到其中的一些静态节点并进行标记，方便在页面重渲染的时候进行diff比较时，直接跳过这一些静态节点，优化runtime的性能。</li> <li>generate阶段：将最终的AST转化为render函数字符串。</li></ul> <h2 id="template预编译是什么"><a href="#template预编译是什么" class="header-anchor">#</a> template预编译是什么？</h2> <p>对于 Vue 组件来说，模板编译只会在组件实例化的时候编译一次，生成渲染函数之后在也不会进行编译。因此，编译对组件的 runtime 是一种性能损耗。</p> <p>而模板编译的目的仅仅是将template转化为<code>render function</code>，这个过程，正好可以在项目构建的过程中完成，这样可以让实际组件在 runtime 时直接跳过模板渲染，进而提升性能，这个在项目构建的编译template的过程，就是预编译。</p> <h2 id="那template和jsx的有什么分别"><a href="#那template和jsx的有什么分别" class="header-anchor">#</a> 那template和jsx的有什么分别？</h2> <p>对于 runtime 来说，只需要保证组件存在 render 函数即可，而我们有了预编译之后，我们只需要保证构建过程中生成 render 函数就可以。</p> <p>在 webpack 中，我们使用<code>vue-loader</code>编译.vue文件，内部依赖的<code>vue-template-compiler</code>模块，在 webpack 构建过程中，将template预编译成 render 函数。</p> <p>与 react 类似，在添加了jsx的语法糖解析器<code>babel-plugin-transform-vue-jsx</code>之后，就可以直接手写render函数。</p> <p>所以，template和jsx的都是render的一种表现形式，不同的是：</p> <p>JSX相对于template而言，具有更高的灵活性，在复杂的组件中，更具有优势，而 template 虽然显得有些呆滞。但是 template 在代码结构上更符合视图与逻辑分离的习惯，更简单、更直观、更好维护。</p> <h2 id="说一下什么是virtual-dom"><a href="#说一下什么是virtual-dom" class="header-anchor">#</a> 说一下什么是Virtual DOM</h2> <p>Virtual DOM 是 DOM 节点在 JavaScript 中的一种抽象数据结构，之所以需要虚拟DOM，是因为浏览器中操作DOM的代价比较昂贵，频繁操作DOM会产生性能问题。虚拟DOM的作用是在每一次响应式数据发生变化引起页面重渲染时，Vue对比更新前后的虚拟DOM，匹配找出尽可能少的需要更新的真实DOM，从而达到提升性能的目的。</p> <h2 id="介绍一下vue中的diff算法"><a href="#介绍一下vue中的diff算法" class="header-anchor">#</a> 介绍一下Vue中的Diff算法</h2> <p>在新老虚拟DOM对比时</p> <ul><li>首先，对比节点本身，判断是否为同一节点，如果不为相同节点，则删除该节点重新创建节点进行替换</li> <li>如果为相同节点，进行patchVnode，判断如何对该节点的子节点进行处理，先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)</li> <li>比较如果都有子节点，则进行updateChildren，判断如何对这些新老节点的子节点进行操作（diff核心）。</li> <li>匹配时，找到相同的子节点，递归比较子节点</li></ul> <p>在diff中，只对同层的子节点进行比较，放弃跨级的节点比较，使得时间复杂从<code>O(n^3)</code>降低值<code>O(n)</code>，也就是说，只有当新旧children都为多个子节点时才需要用核心的Diff算法进行同层级比较。</p> <h2 id="key属性的作用是什么"><a href="#key属性的作用是什么" class="header-anchor">#</a> key属性的作用是什么</h2> <p>在对节点进行diff的过程中，判断是否为相同节点的一个很重要的条件是key是否相等，如果是相同节点，则会尽可能的复用原有的DOM节点。所以key属性是提供给框架在diff的时候使用的，而非开发者。</p> <h2 id="说说vue2-0和vue3-0有什么区别"><a href="#说说vue2-0和vue3-0有什么区别" class="header-anchor">#</a> 说说Vue2.0和Vue3.0有什么区别</h2> <ol><li>重构响应式系统，使用Proxy替换Object.defineProperty，使用Proxy优势：</li></ol> <ul><li>可直接监听数组类型的数据变化</li> <li>监听的目标为对象本身，不需要像Object.defineProperty一样遍历每个属性，有一定的性能提升</li> <li>可拦截apply、ownKeys、has等13种方法，而Object.defineProperty不行</li> <li>直接实现对象属性的新增/删除</li></ul> <ol><li>新增Composition API，更好的逻辑复用和代码组织</li> <li>重构 Virtual DOM</li></ol> <ul><li>模板编译时的优化，将一些静态节点编译成常量</li> <li>slot优化，将slot编译为lazy函数，将slot的渲染的决定权交给子组件</li> <li>模板中内联事件的提取并重用（原本每次渲染都重新生成内联函数）</li></ul> <ol><li>代码结构调整，更便于Tree shaking，使得体积更小</li> <li>使用Typescript替换Flow</li></ol> <h2 id="为什么要新增composition-api-它能解决什么问题"><a href="#为什么要新增composition-api-它能解决什么问题" class="header-anchor">#</a> 为什么要新增Composition API，它能解决什么问题</h2> <p>Vue2.0中，随着功能的增加，组件变得越来越复杂，越来越难维护，而难以维护的根本原因是Vue的API设计迫使开发者使用watch，computed，methods选项组织代码，而不是实际的业务逻辑。</p> <p>另外Vue2.0缺少一种较为简洁的低成本的机制来完成逻辑复用，虽然可以minxis完成逻辑复用，但是当mixin变多的时候，会使得难以找到对应的data、computed或者method来源于哪个mixin，使得类型推断难以进行。</p> <p>所以Composition API的出现，主要是也是为了解决Option API带来的问题，第一个是代码组织问题，Compostion API可以让开发者根据业务逻辑组织自己的代码，让代码具备更好的可读性和可扩展性，也就是说当下一个开发者接触这一段不是他自己写的代码时，他可以更好的利用代码的组织反推出实际的业务逻辑，或者根据业务逻辑更好的理解代码。</p> <p>第二个是实现代码的逻辑提取与复用，当然mixin也可以实现逻辑提取与复用，但是像前面所说的，多个mixin作用在同一个组件时，很难看出property是来源于哪个mixin，来源不清楚，另外，多个mixin的property存在变量命名冲突的风险。而Composition API刚好解决了这两个问题。</p> <h2 id="都说composition-api与react-hook很像-说说区别"><a href="#都说composition-api与react-hook很像-说说区别" class="header-anchor">#</a> 都说Composition API与React Hook很像，说说区别</h2> <p>从React Hook的实现角度看，React Hook是根据useState调用的顺序来确定下一次重渲染时的state是来源于哪个useState，所以出现了以下限制</p> <ul><li>不能在循环、条件、嵌套函数中调用Hook</li> <li>必须确保总是在你的React函数的顶层调用Hook</li> <li>useEffect、useMemo等函数必须手动确定依赖关系</li></ul> <p>而Composition API是基于Vue的响应式系统实现的，与React Hook的相比</p> <ul><li>声明在setup函数内，一次组件实例化只调用一次setup，而React Hook每次重渲染都需要调用Hook，使得React的GC比Vue更有压力，性能也相对于Vue来说也较慢</li> <li>Compositon API的调用不需要顾虑调用顺序，也可以在循环、条件、嵌套函数中使用</li> <li>响应式系统自动实现了依赖收集，进而组件的部分的性能优化由Vue内部自己完成，而React Hook需要手动传入依赖，而且必须必须保证依赖的顺序，让useEffect、useMemo等函数正确的捕获依赖变量，否则会由于依赖不正确使得组件性能下降。</li></ul> <p>虽然Compositon API看起来比React Hook好用，但是其设计思想也是借鉴React Hook的。</p> <h2 id="ssr有了解吗-原理是什么"><a href="#ssr有了解吗-原理是什么" class="header-anchor">#</a> SSR有了解吗？原理是什么？</h2> <p>在客户端请求服务器的时候，服务器到数据库中获取到相关的数据，并且在服务器内部将Vue组件渲染成HTML，并且将数据、HTML一并返回给客户端，这个在服务器将数据和组件转化为HTML的过程，叫做服务端渲染SSR。</p> <p>而当客户端拿到服务器渲染的HTML和数据之后，由于数据已经有了，客户端不需要再一次请求数据，而只需要将数据同步到组件或者Vuex内部即可。除了数据意外，HTML也结构已经有了，客户端在渲染组件的时候，也只需要将HTML的DOM节点映射到Virtual DOM即可，不需要重新创建DOM节点，这个将数据和HTML同步的过程，又叫做客户端激活。</p> <p>使用SSR的好处：</p> <ul><li>有利于SEO：其实就是有利于爬虫来爬你的页面，因为部分页面爬虫是不支持执行JavaScript的，这种不支持执行JavaScript的爬虫抓取到的非SSR的页面会是一个空的HTML页面，而有了SSR以后，这些爬虫就可以获取到完整的HTML结构的数据，进而收录到搜索引擎中。</li> <li>白屏时间更短：相对于客户端渲染，服务端渲染在浏览器请求URL之后已经得到了一个带有数据的HTML文本，浏览器只需要解析HTML，直接构建DOM树就可以。而客户端渲染，需要先得到一个空的HTML页面，这个时候页面已经进入白屏，之后还需要经过加载并执行 JavaScript、请求后端服务器获取数据、JavaScript 渲染页面几个过程才可以看到最后的页面。特别是在复杂应用中，由于需要加载 JavaScript 脚本，越是复杂的应用，需要加载的 JavaScript 脚本就越多、越大，这会导致应用的首屏加载时间非常长，进而降低了体验感。</li></ul> <p>更多详情查看<a href="https://github.com/yacan8/blog/issues/30" target="_blank" rel="noopener noreferrer">彻底理解服务端渲染 - SSR原理<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="参考链接"><a href="#参考链接" class="header-anchor">#</a> 参考链接</h2> <p>https://juejin.cn/post/6919373017218809864</p> <p>https://juejin.cn/post/6850037277675454478</p> <p>https://juejin.cn/post/6844904084374290446</p> <p>https://juejin.cn/post/6844903918753808398</p> <p>https://juejin.cn/post/6870374238760894472</p></div></div> <div class="page-slot page-slot-bottom"><!-- 横向自适应 -->
      <ins class="adsbygoogle"
          style="display:block"
          data-ad-client="ca-pub-7828333725993554"
          data-ad-slot="6620245489"
          data-ad-format="auto"
          data-full-width-responsive="true"></ins>
      <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
      </script></div> <div class="page-edit"><!----> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2021/06/25, 15:41:38</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/rat-summ/pages/92d7a0/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">vue相关基础</div></a> <a href="/rat-summ/pages/e9d2e4/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">vuex相关汇总</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/rat-summ/pages/92d7a0/" class="prev">vue相关基础</a></span> <span class="next"><a href="/rat-summ/pages/e9d2e4/">vuex相关汇总</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><div class="icons"><a href="mailto:yessz@foxmail.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/samyzh" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://music.163.com/" title="听音乐" target="_blank" class="iconfont icon-erji"></a></div> 
    Copyright © 2015-2021
    <span><a href='https://my.samyz.cn' target='_blank'>友一升 | yessz</a></span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <div class="custom-html-window custom-html-window-rb" style="display:;"><div class="custom-wrapper"><i class="close-but">×</i> <div><!-- 固定160*160px -->
      <ins class="adsbygoogle"
          style="display:inline-block;width:160px;height:160px"
          data-ad-client="ca-pub-7828333725993554"
          data-ad-slot="8377369658"></ins>
      <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
      </script>
      </div></div></div></div><div class="global-ui"><!----></div></div>
    <script src="/rat-summ/assets/js/app.d4fe6087.js" defer></script><script src="/rat-summ/assets/js/2.d4f28c34.js" defer></script><script src="/rat-summ/assets/js/32.627a4eb6.js" defer></script><script src="/rat-summ/assets/js/96.e18c84a7.js" defer></script>
  </body>
</html>